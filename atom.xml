<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>懒散集</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lazzyrabbit.github.io/"/>
  <updated>2020-02-15T15:45:57.424Z</updated>
  <id>https://lazzyrabbit.github.io/</id>
  
  <author>
    <name>Zerber</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>推送框架设计一些总结</title>
    <link href="https://lazzyrabbit.github.io/2019/07/11/%E6%8E%A8%E9%80%81%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>https://lazzyrabbit.github.io/2019/07/11/%E6%8E%A8%E9%80%81%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</id>
    <published>2019-07-10T16:03:35.000Z</published>
    <updated>2020-02-15T15:45:57.424Z</updated>
    
    <content type="html"><![CDATA[<p>由于最近在对推送系统做设计，所以可能会持续更新哟～！</p><a id="more"></a><ul><li><a href="#前言">前言(持续更新)</a> </li><li><a href="#架构设计">架构设计</a></li><li><a href="#功能与接口的设计">功能与接口的设计</a></li><li><a href="#群发与推送之间的异同">群发与推送之间的异同</a></li><li><a href="#群发核心分析">群发核心分析</a></li></ul><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>群发系统其实和推送系统是很类似的，都是通过服务器这个中间载体向用户大规模的去推发消息，架构是类似的，但是又不是尽完全相同的，本篇文章会对推送和群发的对比，来说明推送框架设计的核心。</p><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/07/11/%E6%8E%A8%E9%80%81%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/推送整体图.png" alt="推送框架" title>                </div>                <div class="image-caption">推送框架</div>            </figure><p>[此处图片暂时省略。。。]</p><p>Server服务 –&gt; route –&gt; cs –&gt; client</p><h3 id="功能与接口的设计"><a href="#功能与接口的设计" class="headerlink" title="功能与接口的设计"></a>功能与接口的设计</h3><p>推送所需要的功能是保证在长连接连接上App以后，能及时推送消息到用户手机上，以及做好统计记录，所以这其中有几个点是我们在设计接口时需要考虑的。</p><ul><li><strong>在给app推送我们需要推送什么样的消息可以做到对业务方进行接耦合，可以让业务方推送各种类型的消息，而推送服务无感知</strong></li></ul><p>这个就是接口设计上面的问题了，在用户发送的时候我们要做到透传，那么接口的设计是只和我们需要推送的消息类型相关，而跟消息的内容无关。所以在设计上我们可以直接考虑简单的设计：</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PushMsg</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="keyword">required</span> <span class="built_in">i32</span> type                    <span class="comment">// type是可以自己设定的，主要供给客户端解析业务上特殊的类型        </span></span><br><span class="line">    <span class="number">2</span>: <span class="keyword">required</span> <span class="built_in">string</span> content<span class="comment">// 直接透传，一般content里面的是类似于json的字符串，让业务结构到客户端自己解析</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>查询需要通过哪几个维度维度发送与查询</strong></li></ul><p>我们只对带任务式标志的做记录，不重要的推送不会统计入数据库<br>发送时间、版本区间、业务号、userid、token</p><p>其中token是可以针对单条消息进行查询。</p><p><strong>查询内容：</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">目标数(计划推送的目标个数)</span><br><span class="line">有效数(剔除目标数中无效的目标设备后所剩余的个数)</span><br><span class="line">确认到达推送数(推送后台实际下发的目标个数)</span><br><span class="line">点击数(通知栏消息被点击的设备数  客户端埋点)</span><br><span class="line">发送时间</span><br><span class="line">发送速率</span><br><span class="line">版本区间</span><br><span class="line">消息内容</span><br><span class="line">消息token</span><br><span class="line">...</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">* **是否需要保证用户发送的频率**</span><br><span class="line"></span><br><span class="line">对不同业务的发送者来说，不同的消息可能会有不同的发送频率，有一些消息需要点击打开连接，那么需要控制发送速率稍微小一些，以防发送过多，点击量暴增而增加http服务器端的压力，发送的频率可以是下行无限制，也可以是有限制，由发送者控制发送频率。</span><br><span class="line"></span><br><span class="line">* **发送的用户的精准性与个性化推送**</span><br><span class="line"></span><br><span class="line">对于，发送者来说，推送的精准化与个性化是推送的必要需求     </span><br><span class="line"></span><br><span class="line">推送按用户角度分两类：   </span><br><span class="line"></span><br><span class="line">* 对于注册用户的推送</span><br><span class="line">* 对于游客的推送(deviceid推送)</span><br><span class="line"></span><br><span class="line">对于功能性角度分两类：</span><br><span class="line"></span><br><span class="line">* 个推(单注册用户、单游客)</span><br><span class="line">* 群推(多用户、多游客、在线所有人群发)</span><br><span class="line"></span><br><span class="line">### 群发与推送之间的异同</span><br><span class="line"></span><br><span class="line">**相同点** :     </span><br><span class="line"></span><br><span class="line">1. **架构相同**   </span><br><span class="line">都是 </span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"> login_server     </span><br><span class="line">   |     </span><br><span class="line">   |     </span><br><span class="line">Server服务 --&gt; route --&gt; cs --&gt; client 的架构</span><br></pre></td></tr></table></figure><p><strong>不同点</strong> :</p><ul><li><p><strong>存储性质</strong>    </p><ul><li>对于群发：相当于是官方消息发送给每个用户，所以针对必须收到消息的每个用户，每条消息都要存入数据库中，那么就会有批量存入数据库的需求。     </li><li>对于推送：同样是发送，并不具体关心，用户是否收到，而是关心发出去消息的情况。所以只需要存一条消息进入数据库，而对于这条消息的发送量则是它关注的，发送目标数、有效数、确认到达数等。</li></ul></li><li><p><strong>频控性质</strong></p><ul><li>对于群发：频率控制的核心在于对数据库的存储，为了不影响数据库的存储而对用户的发送做频控。</li><li>对于推送：频率控制的核心在于发送者对于业务的把控。</li></ul></li></ul><h3 id="群发核心分析"><a href="#群发核心分析" class="headerlink" title="群发核心分析"></a>群发核心分析</h3><h4 id="对于统计的数据"><a href="#对于统计的数据" class="headerlink" title="对于统计的数据"></a>对于统计的数据</h4><p>对于推送来说，最重要的是每条消息的数据统计。<br>我们可以通过架构设计图看到，统计发送总量的部分在cs，那么我们需要从cs把统计到发送用户的数据给返回回来。</p><h4 id="有效用户和游客"><a href="#有效用户和游客" class="headerlink" title="有效用户和游客"></a>有效用户和游客</h4><p>[分两条线，一条走老的route，一条走新的route]</p><h4 id="频控"><a href="#频控" class="headerlink" title="频控"></a>频控</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于最近在对推送系统做设计，所以可能会持续更新哟～！&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="群发与推送" scheme="https://lazzyrabbit.github.io/tags/%E7%BE%A4%E5%8F%91%E4%B8%8E%E6%8E%A8%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>对于大批量群发消息的一些思考</title>
    <link href="https://lazzyrabbit.github.io/2019/07/07/%E5%AF%B9%E4%BA%8E%E5%A4%A7%E6%89%B9%E9%87%8F%E7%BE%A4%E5%8F%91%E6%B6%88%E6%81%AF%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>https://lazzyrabbit.github.io/2019/07/07/%E5%AF%B9%E4%BA%8E%E5%A4%A7%E6%89%B9%E9%87%8F%E7%BE%A4%E5%8F%91%E6%B6%88%E6%81%AF%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</id>
    <published>2019-07-06T17:14:11.000Z</published>
    <updated>2020-02-09T07:40:37.767Z</updated>
    
    <content type="html"><![CDATA[<p>很长时间没有更新博客了，距上一次发表博客的时间太久远，好吧，我承认我比较低产～～</p><p>在私信中我们通常会遇到给大量用户群发的情况，由于最近在做这一块的优化，所以写写个人的想法与总结</p><a id="more"></a><ul><li><a href="#前言">前言(持续更新)</a>     </li><li><a href="#群发可能的需求">群发可能的需求</a></li><li><a href="#可能面临的问题">可能面临的问题</a></li><li><a href="#对于业务的分析以及接口的设计">对于业务的分析以及接口的设计</a><ul><li><a href="#对于一次可以发多条消息">对于一次可以发多条消息</a></li><li><a href="#对于给指定用户发送">对于给指定用户发送</a></li><li><a href="#对于给指定用户列表发送以及给粉丝群体发送">对于给指定用户列表发送以及给粉丝群体发送</a></li></ul></li><li><a href="#群发系统的设计">群发系统的设计</a><ul><li><a href="#对于批量推送">对于批量推送</a><ul><li>[对于批量推送方案A 所有的集群结合为一个整体的发送系统](#对于批量推送方案A 所有的集群结合为一个整体的发送系统)</li><li>[对于批量推送方案B 每个服务分配到独立的发送任务并且对单一的任务负责到底](#对于批量推送方案B 每个服务分配到独立的发送任务并且对单一的任务负责到底)</li><li><a href="#对于两种方案的看法">对于两种方案的看法</a></li><li><a href="#容灾">容灾</a></li></ul></li><li><a href="#对于给所有有效用户发送">对于给所有有效用户发送</a><pre><code>* [消息场景与抛出问题](#消息场景与抛出问题)* [给出的解决方案](#给出的解决方案)  </code></pre></li></ul></li><li><a href="#总结">总结</a>  </li></ul><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在做私信大规模群发的时候，有这样的场景，就是我们有可能需要给我们的所有用户发送消息或通知，假如有千万级别的用户，甚至到亿级别的用户量，这个时候我们可以根据不同的业务情况对不同的群发要求做处理。</p><p>这里仅对大规模运用于mysql存储IM一对一私信进行总结，其它的方案不在考虑范围之内</p><p>当然这里的设计是依托在原来对于私信的设计之上，以后有机会的话还会对整个私信的架构做一个简单的总结，但是对于本篇文章，有些东西可能会简单的提到(づ′▽`)づ</p><h3 id="群发可能的需求"><a href="#群发可能的需求" class="headerlink" title="群发可能的需求"></a>群发可能的需求</h3><p>由于群发消息是给所有注册有效用户发送消息，所以，这里不包含推送</p><ul><li><p>一次能发送多条消息</p></li><li><p>给指定用户发送</p></li><li><p>给指定用户列表发送</p></li><li><p>给粉丝群体发送</p></li><li><p>给所有效用户发送</p></li><li><p>嵌套式发送</p></li></ul><p>这里是我所承接的需求，每条需求不一样，所以设计的可能就不一样，有一些需求需要存储数据库，这个时候最重要的是容灾以及频控，有一些需求不需要存储，在下行无压力且用户量极高的情况下，我们需要让用户自行的拉取。</p><h3 id="可能面临的问题"><a href="#可能面临的问题" class="headerlink" title="可能面临的问题"></a>可能面临的问题</h3><ol><li><p>影响用户体验 消息发送得慢，并且发送失败。</p></li><li><p>服务崩溃，那么有的消息发送不完全，容灾如何解决</p></li><li><p>发送速率的问题</p></li><li><p>如何推送给所有用户且信息并不需要存储的情况下 </p></li></ol><h3 id="对于业务的分析以及接口的设计"><a href="#对于业务的分析以及接口的设计" class="headerlink" title="对于业务的分析以及接口的设计"></a>对于业务的分析以及接口的设计</h3><h4 id="对于一次可以发多条消息"><a href="#对于一次可以发多条消息" class="headerlink" title="对于一次可以发多条消息"></a>对于一次可以发多条消息</h4><p>我们可以这样设计</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息内容</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MsgAttr</span> </span>&#123;</span><br><span class="line"><span class="number">1</span>: <span class="built_in">i32</span> msgType; <span class="comment">//消息类型</span></span><br><span class="line"><span class="number">2</span>: <span class="keyword">optional</span> RTFMessage rtfMsg;    <span class="comment">//图文消息 MSG_TYPE_ITING</span></span><br><span class="line"><span class="number">3</span>: <span class="keyword">optional</span> TextMessage textMsg;  <span class="comment">//文本消息 MSG_TYPE_TEXT 、MSG_TYPE_PICTURE、 MSG_TYPE_LINK、MSG_TYPE_GROUP_INVITE、MSG_TYPE_SUBSCRIBE、MSG_TYPE_OFFICIAL、MSG_TYPE_OFFICIAL_RECOMMENDED</span></span><br><span class="line"><span class="number">4</span>: <span class="keyword">optional</span> <span class="built_in">bool</span> isStrongNotify;        <span class="comment">//是否为强提醒</span></span><br><span class="line">    <span class="number">5</span>: <span class="keyword">optional</span> <span class="built_in">i32</span> strongNotifyExpireTime; <span class="comment">//强提醒过期时间,为unixtime时间戳,类似1503990460</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送的消息属性</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">XChatMsg</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="built_in">string</span> bizCode;                          <span class="comment">//业务号</span></span><br><span class="line">    <span class="number">2</span>: list&lt;MsgAttr&gt; msgAttrList;            <span class="comment">//信息列表(排好序) 一次最好不要过多</span></span><br><span class="line">    <span class="number">3</span>: <span class="keyword">optional</span> <span class="built_in">string</span> attParam;          <span class="comment">//附带参数 （msgType == RCV_TYPE_PAY_ONE_ALBUM 为 专辑id的字符串、）</span></span><br><span class="line">    <span class="number">4</span>: <span class="keyword">optional</span> <span class="built_in">bool</span> isSubscribe;               <span class="comment">//是否是推荐号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以把多个消息放在一个list中，一个MsgAttr就是一条消息，做成一个消息list，对用户进行发送，这样可以一次发送连续的消息。</p><p><strong>RTFMessage和TextMessage是业务类型中指定的两种类型 具体不列举了</strong></p><h4 id="对于给指定用户发送"><a href="#对于给指定用户发送" class="headerlink" title="对于给指定用户发送"></a>对于给指定用户发送</h4><ul><li><p>对发送做频控，否则影响数据库的读写</p></li><li><p>异步发送处理数据能大大提高效率      </p></li></ul><p><strong>对异步处理的设计：</strong></p><ol><li><p>单开一条线程处理       </p><p> 由于是一条一条消息的存储，并且业务量相对于大规模的群发来说，量并不大，所以每一条的存储消息的时间足够快，所以并不需要考虑多条线程</p></li><li><p>500条/s的存储</p><p>这里设计的时候我是只考虑了单独另外开一条线程处理，因为是，我们可以设计为500条/s–1000条/s存储，甚至可以更多，这个根据数据库的吞吐量以及数据的是否包含其它业务决定，在这里我才用的是500条/s的速率。</p></li></ol><h4 id="对于给指定用户列表发送以及给粉丝群体发送"><a href="#对于给指定用户列表发送以及给粉丝群体发送" class="headerlink" title="对于给指定用户列表发送以及给粉丝群体发送"></a>对于给指定用户列表发送以及给粉丝群体发送</h4><p>在我看来，他们等价，因为指定用户列表是相当于外界传入用户列表，而发送给粉丝群体则是相当于服务内部去粉丝服务上拉到粉丝用户列表并且发送。</p><p><strong>此处有可能存在的问题：拉取粉丝列表过慢</strong></p><p>此处要考虑的问题：</p><ul><li><p>跟发送给指定用户类似，给发送做频控</p></li><li><p>异步发送处理数据能大大提高效率</p></li><li><p>数据库的分表规则以及将一个消息分成多个小包进行批量存储</p></li></ul><p><strong>对于数据库的分表规则以及小包进行批量存储：</strong></p><p>对于小公司或者创业公司来说，用mysql来存储消息，是一个性价比比较高的存储。但是对于大厂来说可能有自己的存储方式，比如Tencent可能会用非关系型数据库加磁盘的方式存储，或者其它的存储方式。在这里我们只针对对于mysql的存储来说吧。</p><p>对于mysql的高效存储来说，一般的话分表是必不可少的，这样可以大大的提高异步存储的效率，只不过说可能真对于具体的业务来说分表的规则有可能不一样，比如按userid分表、token分表等等。我们在大规模批量信息进入数据库的时候就要考虑到分表规则，要将符合相同规则的消息存储于同一个小包中对数据库进行批量存储。</p><p>这里可能有人会问为什么需要大规模的拆分成小包进行存储?</p><p>我们说对于用户的私信发送，也就是每个用户都能看得见的，我们必须要把每一条消息都存入库，那么假如说是百万条消息的话，也就是百万条消息都必须存入库，为了提高存储效率，单条存储入数据库的效率肯定是低下的，因为每次对数据库进行访问都需要进行网络连接，那么我们为了提高效率就必须批量存入。</p><p>在考虑到批量存入的情况下，我们就必须考虑到一次的存储数量能否会给数据库带来压力，每次的数量大概是多少，并且应该遵循分表规则。</p><p>就拿我的业务举例子：</p><ul><li>数据库分表规则: userid后两位分表 100个表</li><li>分小包大小 每个小包500条消息</li></ul><p>那么假如要提高效率的话，userid尾号相同的后两位在一个小包中，即使是100个用户，这个userid 为1-100，那么根据分包规则，因为尾号相同的userid在一个包中，那么分为100个包，每个小包中有1个userid，得存100数据库，根据分包规则，这是在所难免的。当量大了以后，每个包中有500条消息，都是根据userid尾号分好的，可以批量存入表中。</p><p><strong>对异步处理的设计：</strong></p><ol><li><p>开多条线程进行异步处理</p><p> 这里跟给指定用户发送略有不同，由于是对大规模的用户群发，所以这里设计的时候考虑用的是多条线程，这里要对数据库的读写性能进行分析，对于数据库来说，可以进行大规模的批量存储，也就是打包存储，但是数据库是否对于入库的并发量能容忍，这个是要考虑的问题。对于存储线程，我对我们的服务设定的发送线程数为3。</p></li><li><p>500条/s的存储</p><p>3条线程，每条线程500条/s的小包对数据进行存储(注意：这里的条指的是sql语句)，每个小包500条消息(注意：这里的消息指的不是sql语句，而是一条sql语句中批量存储用户的500条消息)，每个线程约存储2500条/s，3个线程7500条/s，这个并发其实足够，在百万级用户面前发送一条消息也只是短短几分钟</p></li></ol><h3 id="群发系统的设计"><a href="#群发系统的设计" class="headerlink" title="群发系统的设计"></a>群发系统的设计</h3><p>其实对于群发系统的设计，我可以说有两套方案，我们老大出了方案A，而我误理解为方案B，各有各的优缺点吧。</p><p>(以下有可能简称一条群发消息任务为大包 而其拆分成为小包进行存储)</p><h4 id="对于批量推送"><a href="#对于批量推送" class="headerlink" title="对于批量推送"></a>对于批量推送</h4><h5 id="与用户私信的发送通道拆分"><a href="#与用户私信的发送通道拆分" class="headerlink" title="与用户私信的发送通道拆分"></a>与用户私信的发送通道拆分</h5><p>这是比较重要的一点，之前的私信群发操作是在批量调用的过程中，调用了用户每条私信的存储函数<br>言简意赅就是把消息的批量存储写为了，多条对用户私信的存储。<br>假如是群发3000条消息，那么就会调用3000条普通私信的存储函数，相当于3000次对数据库的调用。</p><p>缺点：</p><ul><li>对数据库的操作效率是低下的</li><li>对用户是不友好的，因为占用了用户发送消息的通道，假如用户要发送私信，有可能发送失败，因为入库失败～</li></ul><h5 id="容灾"><a href="#容灾" class="headerlink" title="容灾"></a>容灾</h5><p>考虑的问题主要是发送消息在发送一半的时候，假如服务突然挂了，那么剩下的发送任务能不能在下一次重启的时候得到解决，那么对于消息发送进度的临时存储就是一个很必要的问题了。<br>Tencent的容灾很方便，他们有CFS仓库，可以将发送过来的包储存成文件，存储在CFS仓库中。每次群发前先通过hippo组件进行上报并将任务存储在CFS仓库中，在任务发送失败后，通过hippo，diff出差异文件继续发送。 </p><p>而我们相对来说，没有那么一套完整的管理机制，就需要用一些现成的数据系统去做这个第三方的存储，我们首选就是redis。</p><p><strong>容灾存储选择redis理由</strong>    </p><ul><li>非关系型数据库拉取存储效率更高效</li><li>redis中的消息类型足够我们去使用</li><li>临时存储的数据不需要落地，存入只是做备份，当任务执行完后则将存备数据包删除</li></ul><p><strong>对于如何使用redis，方案A和方案B有不同的使用方法</strong></p><h5 id="对于批量推送方案A-所有的集群结合为一个整体的发送系统"><a href="#对于批量推送方案A-所有的集群结合为一个整体的发送系统" class="headerlink" title="对于批量推送方案A 所有的集群结合为一个整体的发送系统"></a>对于批量推送方案A 所有的集群结合为一个整体的发送系统</h5><h6 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h6><p>将大的消息拆成小包放入redis中，redis做队列，每个服务单独领取小包做处理</p><h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><ol><li><p>把整个任务系统作为一个整体，可以不必要去单独的关注一个大包，也不必去关注每一个服务器，可以使每个服务充分的利用去执行一个任务，对一个任务的可执行率更高。 </p></li><li><p>能够容忍小包丢失所带来的失误 </p></li></ol><h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><p>同步操作，相当于每次只对一个大任务包执行任务，将大的任务包拆成小的任务包放入一条队列中，当这个大任务包执行队列被堵死，那么会影响后面的任务发送</p><h5 id="对于批量推送方案B-每个服务分配到独立的发送任务并且对单一的任务负责到底"><a href="#对于批量推送方案B-每个服务分配到独立的发送任务并且对单一的任务负责到底" class="headerlink" title="对于批量推送方案B 每个服务分配到独立的发送任务并且对单一的任务负责到底"></a>对于批量推送方案B 每个服务分配到独立的发送任务并且对单一的任务负责到底</h5><h6 id="规则：-1"><a href="#规则：-1" class="headerlink" title="规则："></a>规则：</h6><p>当一个服务领取到一个大任务包以后，这个大包就归这一个服务所执行，其它的服务器在规定时间内不能执行这个大包，当判定认领这个大包的服务器超时，则将这个大包重新分配到未发送完成的任务队列中，由其他的分布式服务器认领并执行</p><h6 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h6><ol><li>可以多任务同时执行，不会对后面发送的任务造成影响</li><li>在一台服务挂机以后其他任务也能执行</li></ol><h6 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h6><p>过于复杂，相当于自己写了一个对简单的分布式锁的系统，锁的颗粒还特别大，特别粗糙，花费时间长，坑多。</p><h5 id="对于两种方案的看法"><a href="#对于两种方案的看法" class="headerlink" title="对于两种方案的看法"></a>对于两种方案的看法</h5><p>两种方案只是对于任务的安全性不一样。<br>论效率、简易程度，非A莫属，论对于多个任务执行的安全性、以及并发性，那还是方案B，<br>当然，这两种也是各有利弊吧。</p><p>但是它们都有一个共同的点就是对redis的依赖很重，这是由业务的方案决定的，当我们决定需要容灾的时候就需要一个第三方的稳定存储，如果不用redis的话，我们也一样可能会用其他的。</p><h4 id="对于给所有注册用户发送"><a href="#对于给所有注册用户发送" class="headerlink" title="对于给所有注册用户发送"></a>对于给所有注册用户发送</h4><h5 id="消息场景与抛出问题"><a href="#消息场景与抛出问题" class="headerlink" title="消息场景与抛出问题"></a>消息场景与抛出问题</h5><p>对于给所有的注册用户发送消息，这是一个挑战，因为我们的任务场景是：</p><ul><li>无论用户是否在线，皆能收得到消息，并且是面向站内的所有用户，用户单位为亿级</li><li>发送给用户以后不需要再去服务端拉取，本地会缓存住。</li><li>发送只发送一次</li></ul><p>单单是用户是亿级别这个需求都能弄得人脑壳疼对吧，这个事就不能按正常人的思维去脑补它，难点 ：</p><ul><li>亿级别的需求，发送下行没事，对于通过RPC去拉取亿级别的用户名单，这个是不太可能去做到的。</li><li>数据库一次性存储亿级别的消息，影响到后面任务性能。</li></ul><p>根据这些个问题，总结出此任务场景需要反正常的设计：</p><ul><li>单独对这类消息建立一个表，一条消息只存一条进表中     </li><li>用户在更新消息的时候主动来拉这条消息。(主动：给用户一个notify 被动：用户自己来拉 都一样～～～～)</li></ul><p>为什么这么设计呢？</p><ol><li>用户在收到消息以后只做本地存储，也许以后再也不会看到这条消息，这么大容量去推送根本不需要</li><li>这种场景对于群发来说简直不要太不友好。</li></ol><p>好了，考虑到这里我觉得我们应该思考设计一些细节问题，在这里我不简单的提一下我们原来的私信设计，因为群发的业务是依托于私信的架构之上的(后面有时间可能会写私信的结构分析)，不然没法往下分析 <em>( : з 」∠)</em></p><p>当用户没有缓存的时候，私信的客户端会拉取最新的和当前用户有关的消息，大概是2000条左右。<br>当用户有缓存的时候会发送上一次拉取私信的最大id，从上一次拉取私信的最大id往后拉。</p><p>OK～～～一笔带过！！</p><p>那么这里中间我们需要考虑什么问题呢？</p><p>那就是我们几乎对用户每一次的拉取都要加上这条额外的新的消息。<strong>那么对于这条消息存在哪呢</strong></p><ul><li><p>方案A Redis：<br>   假如我们把这条消息存入redis，那么再从redis进行拉取，其实过程上是简单的，但是从效率上来说我们需要两次从数据库中拉取数据，其实用我们老大的经验来说，多从数据库中拉取一次数据会大大损失服务的性能，原因很简单，对于私信的服务来说，拉消息的量要远远高于推消息的量，每一次用户登陆注册进服务器，都要拉取一次数据，假如多增加一次对redis的调用，那么则会增加一次网络耗时，那么相当于对网络性能增加了一倍，而每次拉取，拉取都增加一倍，对于大规模的用户来说，拉取的时间就降低了。</p></li><li><p>方案B 本机的内存中：<br> 假如这条消息是存入的是内存，那么只需要一个从拉取，然后再对所有的一个消息进行重排就Ok，减小了对性能的损耗。</p></li></ul><p>那么OK，对比上面的这两个方案后，我们选择了方案B</p><p>其实这中间，还产生了一些新的问题，<strong>同步问题</strong></p><p>假如用户发送了一条消息，那么这条消息必定生成一个msgid，而生成msgid的规则是不同的，唯一能确保的一点是这个msgid必须唯一，你可以根据时间去生成它，也可以用uuid等规则。。。<br>这里我就说我们用了时间的规则哈</p><p>假如用时间的规则，那么由于时间戳的产生，时间戳经过一些移位等规则，必定是唯一的，那么假如某条消息发送到了一台服务器上，那么此刻如何通知另外的服务器这条消息，另外的话在产生这条消息的同时，我们需要发送一个notify给用户来拉取这条消息，如何在所有服务器都通知到了这条消息以后，再让用户来拉这条消息。(所有的后端业务服务都是分布式的，所以对于和它相处同一层的服务器来说，完全感知不到其它服务器的存在)，那么如何做到在同一层还能互相感知其余的服务器，并且进行通知呢？如果要这么做的话，必须要引入一个类似于redis、zk的第三方，那么就会引入更复杂的问题。</p><p>好吧，那我们先假设动用了这套方案～～！！</p><p>我们假设动用了第三方的存储来给我们做同步，那么会出现第二个问题去考虑，<strong>时间差问题</strong></p><p>假如我们已经做到了一台机器接受到消息以后可以同步给另外的机器，那么我们需要同步的话需要时间。由于我们每台服务器均不知道另外服务器的情况，我们必须让每台服务器定时去第三方的存储中拉取消息，那么中间会产生一个时间差。我们拉取消息的规则是我们根据上一次拉取的id，往后拉，假如我们在获得这条群发消息的过程中，人在聊天，那么它聊天生成的时间戳会大于这条群发的时间戳，那么这条消息即使通知到了其它服务器上，这条消息也不会被拉到，因为客户端有可能在聊天中生成的消息id就大于这条群发消息的id了。</p><h5 id="给出的解决方案"><a href="#给出的解决方案" class="headerlink" title="给出的解决方案"></a>给出的解决方案</h5><p>经过上面的场景以及问题分析，我们知道我们的解决方案主要还是依靠内存，并且还遇到了两个问题，<strong>同步问题</strong> 和 <strong>时间差问题</strong></p><p>假如不能用正常的方式去思考解决这个方案，那么我们只能换一种方式去思考：</p><p><strong>让发送的消息更早的同步到每个服务器，并且让每个消息更早的生成msgid</strong></p><p>这样我们就可以这么设计</p><ul><li>接口增加两个字段 发送时间和有效期时间，发送时间的作用是设定一个未来的发送时间，在未来的发送时间去发送这条消息。有效期日期的作用是，在有效时间内允许服务从数据库中拉取到该数据，由于当客户端拉到消息后存入客户端本地缓存，所以对于每个人来说消息只是拉取一次。</li><li>每个服务定时轮询去数据库收集在有效期前发送的数据，轮询到了以后加载入内存中</li></ul><p>这样做的好处：</p><ul><li>可以让每个服务都能超前获得msgid，对于在未来的某一时刻来说，到了发送时间节点的时候，基本上每个服务都已经同步的获得了需要发送的数据，间接的同步了所有服务器的数据，解决了<strong>同步问题</strong>。</li><li>每个服务器在到定点发送时间的时候，从等待发送的状态，到可以发送的状态，会浪费掉部分时间，虽然这中间可能会有部分用户会在聊天而受到拉不到消息的影响，而对于大部分的用户来说，拉不到消息的几率极小，解决了<strong>时间差问题</strong>。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结就不那么啰嗦了～ 对于这次设计反思和思考太多了，直接在下面列几个点：</p><ul><li>在数据量大的情况下，批量存入数据库，会获得更高的效率，但是最重要的是频控，不要因为一个批量存储影响了其他业务</li><li>redis不仅仅可以用来当缓存，也可以用来做第三方落地式安全存储(AOF模式)，也可以用来充当第三方的数据队列或消息队列，或做备份等。</li><li>在缓存的选择上redis只是一种，但是缺点是会用到网络传输，效率不如自己在本机上的内存。假如在数据一致性或同步性不高的情况下，缓存要善于利用自己机子上的内存，效率会比redis更高。</li><li>在对于结构的设计上，不要太固执，要灵活(当然我觉得有可能是由于我代码写的少(〃′o`) )，就比如让多台服务器同步一条消息，往后延时可以解决同步的问题。</li><li>尽量的往简单的方向去考虑，在实在不得已的情况下再去考虑第三方的插件插入，因为多引入一个服务会增加更多的坑～</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很长时间没有更新博客了，距上一次发表博客的时间太久远，好吧，我承认我比较低产～～&lt;/p&gt;
&lt;p&gt;在私信中我们通常会遇到给大量用户群发的情况，由于最近在做这一块的优化，所以写写个人的想法与总结&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="群发与推送" scheme="https://lazzyrabbit.github.io/tags/%E7%BE%A4%E5%8F%91%E4%B8%8E%E6%8E%A8%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>对于sentinel的SPI接口模式分析</title>
    <link href="https://lazzyrabbit.github.io/2018/12/10/%E5%AF%B9%E4%BA%8Esentinel%E7%9A%84SPI%E6%8E%A5%E5%8F%A3%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/"/>
    <id>https://lazzyrabbit.github.io/2018/12/10/%E5%AF%B9%E4%BA%8Esentinel%E7%9A%84SPI%E6%8E%A5%E5%8F%A3%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/</id>
    <published>2018-12-10T15:54:47.000Z</published>
    <updated>2020-01-23T06:10:07.699Z</updated>
    
    <content type="html"><![CDATA[<p>由于最近时间特别忙，所以自己写这一篇新的blog思考了很长的时间     </p><p>由于自己要写一个简单版本的进程monitor，但是又想去网上去寻找一些新的灵感，所以找到了sentinel这个东西，sentinel本身是阿里的一个开源框架，其实代码本身并不复杂，但是它的框架却相当的灵活，可以自由的加入你所需要做的业务处理，加入框架中，这跟他的SPI链式模式不无关系，所以在这里帮分析一下。</p><a id="more"></a><p><strong>在此鸣谢 逅弈 的博文<br>我只是个人转载而已,都来自同一个作者下的文章，我就转载他的博客就好了，在这里我想说我真的很感谢他，他的博文分析的很详细:</strong></p><p><em><a href="https://www.jianshu.com/u/51121bddcd2a" target="_blank" rel="noopener">https://www.jianshu.com/u/51121bddcd2a</a></em></p><p><strong>也同时鸣谢github中sentinel的开源文档:</strong></p><p><em><a href="https://github.com/alibaba/Sentinel/wiki/Sentinel%E5%B7%A5%E4%BD%9C%E4%B8%BB%E6%B5%81%E7%A8%8B" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel/wiki/Sentinel%E5%B7%A5%E4%BD%9C%E4%B8%BB%E6%B5%81%E7%A8%8B</a></em></p><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>我想说在我们讨论这个话题之前我希望大家先去看一下sentinel的开源文档，对slot的一个定义，这边文章具体的就是说制造slot结构的，slot在sentinel中的概念为插槽。</p><p>sentinel的具体流程大概是这样的</p><p>SphU或SphO生成一个Entry，这个Entry包含了生成的资源名字以及生成的时间id，然后我们在生成Entry的时候我们生成一个slotchain</p><p>slotchain整个一个流程是这样的:</p><p><strong>NodeSelectorSlot–&gt;ClusterBuilderSlot–&gt;StatisticSlot–&gt;FlowSlot–&gt;AuthoritySlot–&gt;DegradeSlot–&gt;SystemSlot</strong></p><p>每一个插槽代表一个功能(具体功能看文档)</p><p>我们一个资源通过这个slotchain这么一走下去啊，他会经历过一系列的统计，判断qps，然后最后判断是否允许它本次操作，最后达到限流的这么一个作用，就相当于一系列的过滤器，最后过滤完了以后看是否合格，再允许本次操作，而且中间非常的灵活，就好像我们一个过滤器里面最上层是石头，然后经过细沙，经过活性炭，最后过滤出来的才是干净的水。这其中slot就相当于其中一种介质，然后我们可以根据自己的业务需要，添加自己的业务介质，所以说这个框架虽然看起来很简单，但是却相当的灵活。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>其实slot的本质很简单，就是一个通过继承搭建起来的(我想说这个继承关系被我老大批的不要不要的，不过后面我自己写的时候也觉得这个结构写起来不太方便)   </p><p>整个继承关系是这样的:<br><strong>DefaultProcessorSlotChain —&gt; ProcessorSlotChain —&gt; AbstractLinkedProcessorSlot —&gt; ProcessorSlot</strong></p><p>我们大概来看一下每一个结构的功能<br>最基础的子类:<br><strong>ProcessorSlot</strong><br>它是一个基本的接口<br>上面的每一层都基本是这个接口的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProcessorSlot</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// entry调用具体的每个slot的实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, T param, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized,</span></span></span><br><span class="line"><span class="function"><span class="params">               Object... args)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 进入到下一个slot</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">fireEntry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, Object obj, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized,</span></span></span><br><span class="line"><span class="function"><span class="params">                   Object... args)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stop调用具体的每个slot的实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(Context context, ResourceWrapper resourceWrapper, <span class="keyword">int</span> count, Object... args)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入到下一个slot </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fireExit</span><span class="params">(Context context, ResourceWrapper resourceWrapper, <span class="keyword">int</span> count, Object... args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是每一个slot的接口，后期所有的slot实现接口当然都是由这个组成<br><strong>AbstractLinkedProcessorSlot</strong><br>对ProcessorSlot的一个基础实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLinkedProcessorSlot</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ProcessorSlot</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> AbstractLinkedProcessorSlot&lt;?&gt; next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fireEntry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, Object obj, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized, Object... args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next.transformEntry(context, resourceWrapper, obj, count, prioritized, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实这里我也不知道用这个大概的意思是啥。。。</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transformEntry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, Object o, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized, Object... args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        T t = (T)o;</span><br><span class="line">        entry(context, resourceWrapper, t, count, prioritized, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fireExit</span><span class="params">(Context context, ResourceWrapper resourceWrapper, <span class="keyword">int</span> count, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next.exit(context, resourceWrapper, count, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AbstractLinkedProcessorSlot&lt;?&gt; getNext() &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(AbstractLinkedProcessorSlot&lt;?&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ProcessorSlotChain</strong><br>组成slot的一个基础类，就是对slot本身的一个管理吧，就是比如添加一个slot，是首部添加还是末尾添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessorSlotChain</span> <span class="keyword">extends</span> <span class="title">AbstractLinkedProcessorSlot</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(AbstractLinkedProcessorSlot&lt;?&gt; protocolProcessor)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(AbstractLinkedProcessorSlot&lt;?&gt; protocolProcessor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DefaultProcessorSlotChain</strong><br>对一个链进行管理的默认处理，相当于链头部节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultProcessorSlotChain</span> <span class="keyword">extends</span> <span class="title">ProcessorSlotChain</span> </span>&#123;</span><br><span class="line"><span class="comment">//由于是头部节点，所以需要特殊处理</span></span><br><span class="line">AbstractLinkedProcessorSlot&lt;?&gt; first = <span class="keyword">new</span> AbstractLinkedProcessorSlot&lt;Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, Object t, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized, Object... args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.fireEntry(context, resourceWrapper, t, count, prioritized, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(Context context, ResourceWrapper resourceWrapper, <span class="keyword">int</span> count, Object... args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.fireExit(context, resourceWrapper, count, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    AbstractLinkedProcessorSlot&lt;?&gt; end = first;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加到队列头部</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(AbstractLinkedProcessorSlot&lt;?&gt; protocolProcessor)</span> </span>&#123;</span><br><span class="line">        protocolProcessor.setNext(first.getNext());</span><br><span class="line">        first.setNext(protocolProcessor);</span><br><span class="line">        <span class="keyword">if</span> (end == first) &#123;</span><br><span class="line">            end = protocolProcessor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加到队列末尾</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(AbstractLinkedProcessorSlot&lt;?&gt; protocolProcessor)</span> </span>&#123;</span><br><span class="line">        end.setNext(protocolProcessor);</span><br><span class="line">        end = protocolProcessor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实总的来说这个结构写起来还是相当复杂的，但是其实没必要，假如说把它做成模版的链式结构可能相对来说更灵活一些，但是可能考虑到比如StatisticSlot要先跑到后面作限流控制再返回到前面的统计节点，所以这么设计。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于最近时间特别忙，所以自己写这一篇新的blog思考了很长的时间     &lt;/p&gt;
&lt;p&gt;由于自己要写一个简单版本的进程monitor，但是又想去网上去寻找一些新的灵感，所以找到了sentinel这个东西，sentinel本身是阿里的一个开源框架，其实代码本身并不复杂，但是它的框架却相当的灵活，可以自由的加入你所需要做的业务处理，加入框架中，这跟他的SPI链式模式不无关系，所以在这里帮分析一下。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="sentinel" scheme="https://lazzyrabbit.github.io/tags/sentinel/"/>
    
  </entry>
  
  <entry>
    <title>SimpleRabbitmqClient剖析</title>
    <link href="https://lazzyrabbit.github.io/2018/11/27/SimpleRabbitmqClient%E5%89%96%E6%9E%90/"/>
    <id>https://lazzyrabbit.github.io/2018/11/27/SimpleRabbitmqClient%E5%89%96%E6%9E%90/</id>
    <published>2018-11-26T16:58:26.000Z</published>
    <updated>2018-11-26T16:58:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>SimpleRabbitmqClient是一个对于Rabbitmq的C接口库rabbitmq-c上做的一层封装   </p><p><strong>为什么要封装rabbitmq-c</strong>    </p><p>rabbitmq-c是对C的一个接口，它有太多的自己定义的类型，比如我们要往rabbitmq-c的函数中添加一个字符串总要把它变为amqp_cstring_bytes(…)，rabbitmq-c的一些自定义类型太复杂，而我们根本不需要去关心，我们只需要关心传进去的值和返回的结果。    </p><p>SimpleRabbitmqClient做了:<br>1、把复杂的rabbitmq-c接口转化成通俗的C++接口<br>2、封装了对客户端的连接管理以及错误处理</p><a id="more"></a><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>跨平台 兼容Windows和Linux</li><li>接口多、更灵活、封装了连接管理以及错误处理</li><li>做了一个对consume的管理</li></ul><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/11/27/SimpleRabbitmqClient%E5%89%96%E6%9E%90/简单剖析图.png" alt="简单剖析图" title>                </div>                <div class="image-caption">简单剖析图</div>            </figure><h3 id="剖析"><a href="#剖析" class="headerlink" title="剖析"></a>剖析</h3><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>对rabbitmq的类型做了一个转换，就是做了一个普通封装，但是没有什么实际操作   </p><p>其中包括:    </p><ul><li>网络连接的判断</li><li>doLogin 、doRpc<br>(ps: doLogin、doRpc这个直接就是对rabbitmq的操作，只不过这一层封装在ChannelImpl中)</li></ul><h4 id="ChannelImpl"><a href="#ChannelImpl" class="headerlink" title="ChannelImpl"></a>ChannelImpl</h4><ul><li>对rabbitmq的一个实际操作，这里面做了很多主要的的工作，就比如:     </li></ul><ol><li>doLogin<br> 实际上就是对登陆的一个封装操作，但是封装的参数相对会多一些，一般好像直接用    amqp_login登陆，他用的是amqp_login_with_properties，也是很用心了</li><li>doRpc<br> 对rabbitmq-c操作的一些处理，包括错误处理等</li></ol><ul><li>对consume的一个管理，建立一个map表，当生成一个consume的时候，注册进map并返回相应的consumeTag(我的理解就是在单线程中有多个consume)</li></ul><h4 id="TableValueImpl"><a href="#TableValueImpl" class="headerlink" title="TableValueImpl"></a>TableValueImpl</h4><p>对于amqp_table_t的一个对外封装，实际上是自己写的一个Table，主要用于argument，为了能让外部对amqp_table_t更好用，所以提供了一个Table，在内部转化为amqp_table_t。<br>(不过他这个地方倒是又一个很有意思的东西，用了amqp_pool_t，这是rabbitmq-c中自带的一个memory pool，用这个生成了一个amqp_pool_t。话说回来我实在是看不懂为什么要这么骚操作)</p><h4 id="Envelope"><a href="#Envelope" class="headerlink" title="Envelope"></a>Envelope</h4><p>一个信封，封装了返回的message,我觉得这个我没什么说的，但实际上这个信封对外提供了很多Get的方便的接口，ChannelImpl在接收到生成的消息以后会去调用</p><h4 id="BasicMessageImpl"><a href="#BasicMessageImpl" class="headerlink" title="BasicMessageImpl"></a>BasicMessageImpl</h4><p>这个东西我也是后来剖析完整体框架以后看的吧，所以我也没有把这个画到图里面去<br>他的主要功能还是用m_body封装了返回过来的信息<br>我就是想说一下里面用了amqp_basic_properties_t这个结构体很有意思，就是这个结构体好像是rabbitmq-c本身的一个结构体，它相当于提供给用户封装一些userid之类的基本属性，第一次见，所以感觉这个作者应该也是很用心了，把rabbitmq-c这个库封装到极致了</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我来个人评价一下这个库吧，不喜勿喷:     </p><ul><li><p><strong>这个库的封装是极致的</strong><br>对于rabbitmq的封装性来说，我觉得这个库是完美的，极致的，我能说基本上所有的rabbitmq-c的类型使用到了极致，感觉没有什么看漏的吧。(包括<strong>BasicMessage</strong>中有<strong>amqp_basic_properties_t</strong>这种类型，我的妈)</p></li><li><p><strong>写法过于中规中矩</strong><br>没有什么特别让人眼前一亮的东西，就是结构很简单吧我觉得，基本没用什么设计模式，所以我感觉看起没什么特别值得剖析的地方，没有对某一块地方拿出来说，但是用起来就很灵活了</p></li><li><p><strong>过于依赖boost</strong><br>很好奇为什么不用C11！ </p></li></ul><p>其实我想大家对这个库有什么独特的看法也可以来联系我的，我会出剖析</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;SimpleRabbitmqClient是一个对于Rabbitmq的C接口库rabbitmq-c上做的一层封装   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要封装rabbitmq-c&lt;/strong&gt;    &lt;/p&gt;
&lt;p&gt;rabbitmq-c是对C的一个接口，它有太多的自己定义的类型，比如我们要往rabbitmq-c的函数中添加一个字符串总要把它变为amqp_cstring_bytes(…)，rabbitmq-c的一些自定义类型太复杂，而我们根本不需要去关心，我们只需要关心传进去的值和返回的结果。    &lt;/p&gt;
&lt;p&gt;SimpleRabbitmqClient做了:&lt;br&gt;1、把复杂的rabbitmq-c接口转化成通俗的C++接口&lt;br&gt;2、封装了对客户端的连接管理以及错误处理&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="SimpleRabbitmqClient" scheme="https://lazzyrabbit.github.io/tags/SimpleRabbitmqClient/"/>
    
  </entry>
  
  <entry>
    <title>SimpleRabbitmqClient Demo</title>
    <link href="https://lazzyrabbit.github.io/2018/11/15/SimpleRabbitmqClient-Demo/"/>
    <id>https://lazzyrabbit.github.io/2018/11/15/SimpleRabbitmqClient-Demo/</id>
    <published>2018-11-15T11:36:56.000Z</published>
    <updated>2018-11-26T16:58:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>我就想把我写的关于SimpleRabbitmqClient的Demo上传一下，方便以后后人查阅吧</p><a id="more"></a><p><strong>Consume:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Zerber(Lazy_Rabbit) 懒散兔 Zzzzz... </span></span><br><span class="line"><span class="comment"> * @Date: 2018-11-14 15:11:01 </span></span><br><span class="line"><span class="comment"> * @Last Modified by: Zerber(Lazy_Rabbit) 懒散兔 Zzzzz...</span></span><br><span class="line"><span class="comment"> * @Last Modified time: 2018-11-14 16:45:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SimpleAmqpClient/SimpleAmqpClient.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_QUEUE_1 <span class="meta-string">"test.Queue1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_QUEUE_2 <span class="meta-string">"test.Queue2"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_EXCHANGE_RABBIT <span class="meta-string">"test.exchange.rabbit"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_EXCHANGE_TIGER <span class="meta-string">"test.exchange.tiger"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Generate some methods for detecting interfaces</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumeOpr</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span> (<span class="keyword">void</span>)&gt; TTestFun;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span> (<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>)&gt; TQueueMsgHandler;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Parm</span> &#123;</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> host; </span><br><span class="line">        <span class="keyword">int</span> port;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> userName;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> password;</span><br><span class="line">        </span><br><span class="line">        Parm():port(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    &#125;;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Init</span><span class="params">(<span class="keyword">const</span> Parm&amp; parm)</span> </span>&#123;</span><br><span class="line">        parm_ = parm;</span><br><span class="line">        <span class="keyword">if</span>(parm_.host.empty() || parm_.userName.empty() || parm_.password.empty() || parm_.port&lt;=<span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"init false!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel_ = AmqpClient::Channel::Create(parm_.host, parm_.port, parm_.userName, parm_.password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="built_in">std</span>::exception&amp; e) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"init false error["</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//this demo is test for more exchanges bind in one queue.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TestTwoQueueAndExchanges</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; queueName)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; queueNames;</span><br><span class="line">        queueNames.push_back(queueName);</span><br><span class="line"></span><br><span class="line">        TTestFun testFun = [&amp;]() &#123;</span><br><span class="line">            <span class="comment">//channel_-&gt;DeclareQueue(queueName, false, true, false, false);</span></span><br><span class="line">            ListenLoop_(queueNames, ConsumeOpr::DefaultQueueMsgFun);</span><br><span class="line">        &#125;;</span><br><span class="line">        ThrowExceFrame_(testFun);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TestMoreConsumeWithRoutingkey</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; queueNames)</span> </span>&#123;</span><br><span class="line">        TTestFun testFun = [&amp;]() &#123;</span><br><span class="line">            <span class="comment">//for(std::string queueName : queueNames) &#123;</span></span><br><span class="line">                <span class="comment">//channel_-&gt;DeclareQueue(queueName, false, true, false, false);</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            ListenLoop_(queueNames, ConsumeOpr::DefaultQueueMsgFun);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        ThrowExceFrame_(testFun);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DefaultQueueMsgFun</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> msgExch, <span class="built_in">std</span>::<span class="built_in">string</span> msgBody, <span class="built_in">std</span>::<span class="built_in">string</span> consumeTag)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"msgExch["</span> &lt;&lt; msgExch &lt;&lt; <span class="string">"] msgBody["</span> &lt;&lt; msgBody &lt;&lt; <span class="string">"] consumeTag["</span> &lt;&lt; consumeTag &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ThrowExceFrame_</span><span class="params">(TTestFun testFun)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                testFun();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(<span class="built_in">std</span>::exception&amp; e) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"test error["</span> &lt;&lt; e.what()&lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ListenLoop_</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; queueNames, TQueueMsgHandler queueMsgHandler)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; consumerTags;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="built_in">string</span> queueName : queueNames) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> consumeTag = channel_-&gt;BasicConsume(queueName);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"tag["</span> &lt;&lt; consumeTag &lt;&lt; <span class="string">"], queueName["</span> &lt;&lt; queueName &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            consumerTags.push_back(consumeTag);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//BasicConsumeMessage有非vec版本，自己看接口了</span></span><br><span class="line">            <span class="keyword">auto</span> msg = channel_-&gt;BasicConsumeMessage(consumerTags);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> exch = msg-&gt;Exchange();</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> body = msg-&gt;Message()-&gt;Body();</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> consumeTag = msg-&gt;ConsumerTag();</span><br><span class="line">            queueMsgHandler(exch, body, consumeTag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Parm parm_;</span><br><span class="line">    AmqpClient::Channel::<span class="keyword">ptr_t</span> channel_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ConsumeOpr::Parm consumeOprParm;</span><br><span class="line">    consumeOprParm.host = <span class="string">"192.168.3.161"</span>;</span><br><span class="line">    consumeOprParm.port = <span class="number">5672</span>;</span><br><span class="line">    consumeOprParm.userName = <span class="string">"guest"</span>;</span><br><span class="line">    consumeOprParm.password = <span class="string">"guest"</span>;</span><br><span class="line"></span><br><span class="line">    ConsumeOpr consumeOpr;</span><br><span class="line">    consumeOpr.Init(consumeOprParm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//consumeOpr.TestOneQueueAndExchanges(TEST_QUEUE_1);</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; queueNames;</span><br><span class="line">    queueNames.push_back(TEST_QUEUE_1);</span><br><span class="line">    queueNames.push_back(TEST_QUEUE_2);</span><br><span class="line">    consumeOpr.TestMoreConsumeWithRoutingkey(queueNames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Producer:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: Zerber(Lazy_Rabbit) 懒散兔 Zzzzz... </span></span><br><span class="line"><span class="comment"> * @Date: 2018-11-14 15:10:55 </span></span><br><span class="line"><span class="comment"> * @Last Modified by: Zerber(Lazy_Rabbit) 懒散兔 Zzzzz...</span></span><br><span class="line"><span class="comment"> * @Last Modified time: 2018-11-14 16:48:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SimpleAmqpClient/SimpleAmqpClient.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_QUEUE_1 <span class="meta-string">"test.Queue1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_QUEUE_2 <span class="meta-string">"test.Queue2"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_EXCHANGE_RABBIT <span class="meta-string">"test.exchange.rabbit"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_EXCHANGE_TIGER <span class="meta-string">"test.exchange.tiger"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducertOpr</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span> (<span class="keyword">void</span>)&gt; TTestFun;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Parm</span> &#123;</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> host; </span><br><span class="line">        <span class="keyword">int</span> port;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> userName;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> password;</span><br><span class="line">        </span><br><span class="line">        Parm():port(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    &#125;;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Init</span><span class="params">(<span class="keyword">const</span> Parm&amp; parm)</span> </span>&#123;</span><br><span class="line">        parm_ = parm;</span><br><span class="line">        <span class="keyword">if</span>(parm_.host.empty() || parm_.userName.empty() || parm_.password.empty() || parm_.port&lt;=<span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"init false!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel_ = AmqpClient::Channel::Create(parm_.host, parm_.port, parm_.userName, parm_.password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="built_in">std</span>::exception&amp; e) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"init false!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//main thread loop</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TestMoreExchageToOneQueueWithOutRoutingkey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TTestFun testFun = [&amp;]() &#123;</span><br><span class="line">            channel_-&gt;DeclareExchange(TEST_EXCHANGE_RABBIT, AmqpClient::Channel::EXCHANGE_TYPE_DIRECT);</span><br><span class="line">            channel_-&gt;DeclareExchange(TEST_EXCHANGE_TIGER, AmqpClient::Channel::EXCHANGE_TYPE_DIRECT);</span><br><span class="line">            channel_-&gt;DeclareQueue(TEST_QUEUE_1, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            channel_-&gt;BindQueue(TEST_QUEUE_1, TEST_EXCHANGE_RABBIT);</span><br><span class="line">            channel_-&gt;BindQueue(TEST_QUEUE_1, TEST_EXCHANGE_TIGER);</span><br><span class="line">            LoopToSendMsg_(<span class="literal">false</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        ThrowExceFrame_(testFun);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TestMoreExchageToOneQueueWithRoutingkey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TTestFun testFun = [&amp;]() &#123;</span><br><span class="line">            channel_-&gt;DeclareExchange(TEST_EXCHANGE_RABBIT, AmqpClient::Channel::EXCHANGE_TYPE_DIRECT);</span><br><span class="line">            channel_-&gt;DeclareExchange(TEST_EXCHANGE_TIGER, AmqpClient::Channel::EXCHANGE_TYPE_DIRECT);</span><br><span class="line">            channel_-&gt;DeclareQueue(TEST_QUEUE_1, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            channel_-&gt;DeclareQueue(TEST_QUEUE_2, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            channel_-&gt;BindQueue(TEST_QUEUE_1, TEST_EXCHANGE_RABBIT, <span class="string">"rabbit"</span>);</span><br><span class="line">            channel_-&gt;BindQueue(TEST_QUEUE_2, TEST_EXCHANGE_TIGER, <span class="string">"tiger"</span>);</span><br><span class="line">            LoopToSendMsg_(<span class="literal">true</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        ThrowExceFrame_(testFun);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ThrowExceFrame_</span><span class="params">(TTestFun testFun)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testFun();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(<span class="built_in">std</span>::exception&amp; e) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"test error["</span> &lt;&lt; e.what()&lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LoopToSendMsg_</span><span class="params">(<span class="keyword">bool</span> isRouteKey)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> exchangeName;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> queueName;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> message;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> routeKey;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!isRouteKey) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"write [exchange] [queueName] [message] to send:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; exchangeName &gt;&gt; queueName &gt;&gt; message;</span><br><span class="line"></span><br><span class="line">                channel_-&gt;BasicPublish(exchangeName, <span class="string">""</span>, AmqpClient::BasicMessage::Create(message));</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"exchangeName["</span> &lt;&lt; exchangeName &lt;&lt; <span class="string">"] , queueName["</span> &lt;&lt; queueName &lt;&lt; <span class="string">"] , message["</span> &lt;&lt; message &lt;&lt; <span class="string">"] has been send."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"write [exchange] [routeKey] [message] to send:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; exchangeName  &gt;&gt; routeKey &gt;&gt; message;</span><br><span class="line"></span><br><span class="line">                channel_-&gt;BasicPublish(exchangeName, routeKey, AmqpClient::BasicMessage::Create(message));</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"exchangeName["</span> &lt;&lt; exchangeName &lt;&lt; <span class="string">"] , routeKey["</span> &lt;&lt; routeKey &lt;&lt; </span><br><span class="line">                             <span class="string">"] , message["</span> &lt;&lt; message &lt;&lt; <span class="string">"] has been send."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Parm parm_;</span><br><span class="line">    AmqpClient::Channel::<span class="keyword">ptr_t</span> channel_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ProducertOpr::Parm producertOprParm;</span><br><span class="line">    producertOprParm.host = <span class="string">"192.168.3.161"</span>;</span><br><span class="line">    producertOprParm.port = <span class="number">5672</span>;</span><br><span class="line">    producertOprParm.userName = <span class="string">"guest"</span>;</span><br><span class="line">    producertOprParm.password = <span class="string">"guest"</span>;</span><br><span class="line"></span><br><span class="line">    ProducertOpr producertOpr;</span><br><span class="line">    producertOpr.Init(producertOprParm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//match consume fun [TestTwoQueueAndExchanges]</span></span><br><span class="line">    <span class="comment">//producertOpr.TestMoreExchageToOneQueueWithOutRoutingey();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//match consume fun [TestMoreThreadWithRoutingkey]</span></span><br><span class="line">    producertOpr.TestMoreExchageToOneQueueWithRoutingkey();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我就想把我写的关于SimpleRabbitmqClient的Demo上传一下，方便以后后人查阅吧&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="SimpleRabbitmqClient" scheme="https://lazzyrabbit.github.io/tags/SimpleRabbitmqClient/"/>
    
  </entry>
  
  <entry>
    <title>对于ndk的使用</title>
    <link href="https://lazzyrabbit.github.io/2018/04/23/%E5%AF%B9%E4%BA%8Endk%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://lazzyrabbit.github.io/2018/04/23/%E5%AF%B9%E4%BA%8Endk%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2018-04-23T13:10:19.000Z</published>
    <updated>2020-02-15T16:39:20.438Z</updated>
    
    <content type="html"><![CDATA[<p>最近老大让我开发一个流媒体播放器，这里面需要用到NDK，大家都是在平时的过程中熟悉使用了JDK，很少使用NDK</p><a id="more"></a><p>NDK是个什么玩意呢？<br>让我们对以下几个概念做一个解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SDK:(Software Development Kit)软件开发工具包;这是一个覆盖面相当广泛的名词，可以这么说：辅助开发某一类软件的相关文档、API必需资料、范例和工具的集合都可以叫做 &quot;SDK&quot;。在安卓开发中我们所说的SDK即为android SDK，它为开发者提供了库文件以及其他开发所用到的工具；一般说的SDK就是开发工具了，再加一个开发IDE，就搭建起一个开发环境了，比如 eclipse + android SDK 的IDE</span><br><span class="line"></span><br><span class="line">NDK:(Native Development Kit)跟android SDK差不多也是一个开发工具包，是用来给安卓手机开发软件用的，但是和SDK不同的是它用的是C语言，而android SDK用的是Java语言；</span><br><span class="line"></span><br><span class="line">JDK:(Java Development Kit) Java语言的软件开发工具包，Java核心，包括Java运行环境、类库、Java开发工具，简单的说JDK就是面向Java开发人员使用的SDK ；</span><br><span class="line"></span><br><span class="line">ADT:(Android Developer Tools),安卓开发工具，Google研发的一个插件，集成在eclipse中，为安卓开发提供专属开发环境，简单的说ADT就是Android在Eclipse上的开发工具，在Eclipse和SDK之间起到了一个桥梁的作用；</span><br><span class="line"></span><br><span class="line">ANT:是Apache的一个项目管理工具，是一个可将软件编译、测试、部署等步骤联系在一起加以自动化的工具，大多用于Java环境中的软件开发。</span><br></pre></td></tr></table></figure><p>总而言之就是我们利用C和C++来给Android来写程序<br>我们通过JNI来实现JAVA和C、C++之间的通信(详细信息便不再说明)</p><p>这里我主要来说一下，我打通从手机的adb到mac之间的一些操作<br>刚开始我下了一个Android Studio，你们知道AS本身带有很强大的下载JDK包的功能，我就顺手利用AS下了NDK</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">过程为：Tools-&gt;SDK Manager-&gt;Android SDK-&gt;SDK Tools</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/04/23/%E5%AF%B9%E4%BA%8Endk%E7%9A%84%E4%BD%BF%E7%94%A8/Android-1.jpeg" alt="Android-1" title>                </div>                <div class="image-caption">Android-1</div>            </figure><p>(当然前两部省略在上面隐形了)</p><p>当然，此时安装好以后我们就可以新建一个C++的项目了，比如:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/04/23/%E5%AF%B9%E4%BA%8Endk%E7%9A%84%E4%BD%BF%E7%94%A8/Android-2.jpeg" alt="Android-2" title>                </div>                <div class="image-caption">Android-2</div>            </figure><p>自然而然的生成一个项目</p><p>这个时候我们可以看到这么一个项目</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/04/23/%E5%AF%B9%E4%BA%8Endk%E7%9A%84%E4%BD%BF%E7%94%A8/Android-3.jpeg" alt="Android-3" title>                </div>                <div class="image-caption">Android-3</div>            </figure><p>我们可以看到这部分基本都是自动生成的</p><p>在这里我们可以打开MainActivity</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/04/23/%E5%AF%B9%E4%BA%8Endk%E7%9A%84%E4%BD%BF%E7%94%A8/Android-4.jpeg" alt="Android-4" title>                </div>                <div class="image-caption">Android-4</div>            </figure><p>假设我们写一个函数，便会生成一个基本函数<br>但是这样还是不够的<br>我们还需要JNI来打通C、C++和Java之间的通道<br>底下便是终端</p><p>我们需要到java文件夹下输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javah -d jni -jni com.example.nali.ndkapplication.MainActivity</span><br></pre></td></tr></table></figure><p>生成.h头文件</p><p>一般这个时候点编译和run，就能输出最基本的app了，可以运行了</p><p>当然这个是打通我们和手机的第一步，就是可以利用AS编译NDK了，剩下的我们要对流媒体算法本身进行封装，要打通手机和shell之间的通道，利用adb shell，打开手机，并在终端上写下一个hello world！</p><p>这个配置就配置很久了，看了网上的很多很多攻略，汇总在下面这里：</p><h4 id="1-ndk-build"><a href="#1-ndk-build" class="headerlink" title="1. ndk-build"></a>1. ndk-build</h4><p>找了大部分网上对于ndk包的处理，大部分都是直接下载android的ndk包</p><p>比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H:\gp\Android\android-ndk-r9</span><br></pre></td></tr></table></figure><p>这种配置<br>对于它们都比较好配置路径，而我的ndk包是从AS上下载下来的，所以路径不太一样</p><p>我的路径是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;Users&#x2F;nali&#x2F;Library&#x2F;Android&#x2F;sdk&#x2F;ndk-bundle</span><br></pre></td></tr></table></figure><p>这个时候我们想使用ndk-build这个命令，但是其他文件夹并不能使用，这个时候我们需要配置一下这个命令</p><h5 id="1-进入当前用户的home目录"><a href="#1-进入当前用户的home目录" class="headerlink" title="1. 进入当前用户的home目录"></a>1. 进入当前用户的home目录</h5><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ～ (注意中间的空格)</span><br></pre></td></tr></table></figure><h5 id="2-创建-bash-profile-文件"><a href="#2-创建-bash-profile-文件" class="headerlink" title="2. 创建 .bash_profile 文件"></a>2. 创建 .bash_profile 文件</h5><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch .bash\_profile</span><br></pre></td></tr></table></figure><h5 id="3-编辑-bash-profile文件"><a href="#3-编辑-bash-profile文件" class="headerlink" title="3. 编辑 .bash_profile文件"></a>3. 编辑 .bash_profile文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入 open -e .bash\_profile</span><br></pre></td></tr></table></figure><h5 id="4-在后面加两行"><a href="#4-在后面加两行" class="headerlink" title="4. 在后面加两行"></a>4. 在后面加两行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ANDROID\_NDK\_ROOT&#x3D;&#x2F;Users&#x2F;nali&#x2F;Library&#x2F;Android&#x2F;sdk&#x2F;ndk-bundle</span><br><span class="line">export PATH&#x3D;$PATH:$ANDROID\_NDK\_ROOT</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/04/23/%E5%AF%B9%E4%BA%8Endk%E7%9A%84%E4%BD%BF%E7%94%A8/Android-6.jpeg" alt="Android-6" title>                </div>                <div class="image-caption">Android-6</div>            </figure><h5 id="5-然后保存"><a href="#5-然后保存" class="headerlink" title="5. 然后保存"></a>5. 然后保存</h5><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure><h4 id="2-这个东西配置好以后，我们在任意文件夹输入ndk-build都会出现下面的"><a href="#2-这个东西配置好以后，我们在任意文件夹输入ndk-build都会出现下面的" class="headerlink" title="2. 这个东西配置好以后，我们在任意文件夹输入ndk-build都会出现下面的:"></a>2. 这个东西配置好以后，我们在任意文件夹输入ndk-build都会出现下面的:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#:~ nali$ ndk-build</span><br><span class="line">Android NDK: Could not find application project directory !</span><br><span class="line">Android NDK: Please define the NDK_PROJECT_PATH variable to point to it.</span><br><span class="line">&#x2F;Users&#x2F;nali&#x2F;Library&#x2F;Android&#x2F;sdk&#x2F;ndk-bundle&#x2F;build&#x2F;core&#x2F;build-local.mk:151: *** Android NDK: Aborting    .  Stop.</span><br></pre></td></tr></table></figure><h4 id="3-这个时候我们做一个测试"><a href="#3-这个时候我们做一个测试" class="headerlink" title="3. 这个时候我们做一个测试"></a>3. 这个时候我们做一个测试</h4><p>我们建立一个文件夹，并在里面建立一个jni文件，并在里面写一个简单的</p><figure class="highlight plain"><figcaption><span>world```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![hello-world](对于ndk的使用&#x2F;hello-world.jpeg)</span><br><span class="line"></span><br><span class="line">这里包括一个Android.mk，是类似于makefile的一个东西，只不过用ndk-build来调用</span><br><span class="line">里面的格式：</span><br></pre></td></tr></table></figure><p>LOCAL_PATH := $(call my-dir)</p><p>include $(CLEAR_VARS)<br>LOCAL_MODULE := hello<br>LOCAL_SRC_FILES := hello.c<br>LOCAL_CFLAGS += -pie -fPIE<br>LOCAL_LDFLAGS += -pie -fPIE<br>include $(BUILD_EXECUTABLE)<br>~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中 &#96;&#96;&#96;LOCAL_CFLAGS +&#x3D; -pie -fPIE&#96;&#96;&#96; 和 &#96;&#96;&#96;LOCAL_LDFLAGS +&#x3D; -pie -fPIE&#96;&#96;&#96; 这两个参数我后面会解释</span><br><span class="line"></span><br><span class="line">来说一下可能遇到的错误</span><br></pre></td></tr></table></figure><p>(1)Android NDK: APP_PLATFORM not set. Defaulting to minimum supported version android-14.<br>make: *** No rule to make target <code>/Users/nali/Library/Android/sdk/ndk-bundle/sources/cxx-stl/system/hello.c&#39;, needed by</code>/Users/nali/work/ndkTest/obj/local/arm64-v8a/objs/hello/hello.o’.  Stop.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**PS:肯定是你格式没写对，要不然就加了特殊字符**</span><br></pre></td></tr></table></figure><p>(2)开头有 No rule to make target<br>PS:多试几次source .bash_profile 说明你没配置好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">还有几种错误忘记了，我们继续往下走吧</span><br><span class="line"></span><br><span class="line">#### 4. 执行成功以后，jni文件夹外会生成两个文件，一个是libs文件夹，另外一个是obj</span><br><span class="line">接下来进入adb shell</span><br></pre></td></tr></table></figure><p>adb push libs/armeabi/helloworld  /data</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们有可能会遇到这么一种情况：</span><br></pre></td></tr></table></figure><p>Permission denied</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我只能告诉你，你手机需要root了     </span><br><span class="line">我们继续的话还有可能还需要改写data权限    </span><br><span class="line">chmod 777 data    </span><br><span class="line"></span><br><span class="line">#### 5. 解决了上面这个问题</span><br><span class="line"></span><br><span class="line"> 很可能会出现下面这个问题有可能会遇到下面这个问题：</span><br></pre></td></tr></table></figure><p> error: only position independent executables (PIE) are supported.</p><pre><code>这个时候需要我们说的上面两个参数:```LOCAL_CFLAGS += -pie -fPIE``` 和 ```LOCAL_LDFLAGS += -pie -fPIE``` ---------------------------------------------------**部分转载自：https://blog.csdn.net/yangzhaomuma/article/details/50467825https://blog.csdn.net/shouhouhuakai/article/details/40892863https://blog.csdn.net/wkl305268748/article/details/13504171**</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近老大让我开发一个流媒体播放器，这里面需要用到NDK，大家都是在平时的过程中熟悉使用了JDK，很少使用NDK&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Android" scheme="https://lazzyrabbit.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>利用muduo原线程池修改的可调度线程池源码</title>
    <link href="https://lazzyrabbit.github.io/2017/09/24/%E5%88%A9%E7%94%A8muduo%E5%8E%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BF%AE%E6%94%B9%E7%9A%84%E5%8F%AF%E8%B0%83%E5%BA%A6%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81/"/>
    <id>https://lazzyrabbit.github.io/2017/09/24/%E5%88%A9%E7%94%A8muduo%E5%8E%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BF%AE%E6%94%B9%E7%9A%84%E5%8F%AF%E8%B0%83%E5%BA%A6%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81/</id>
    <published>2017-09-24T08:14:07.000Z</published>
    <updated>2020-02-15T16:56:41.576Z</updated>
    
    <content type="html"><![CDATA[<p>nothing</p><a id="more"></a><p>由于muduo的线程池是抢占式的，在锁过多利用的情况下我们需要自己利用自己的规则去分配和调度线程，我这个实现的就是一个可自己分配和调度的线程池，其特点有以下几点</p><ol><li>每个线程都有自己的消息队列并且大小不限</li><li>每个线程都可自由阻塞，但是消息队列正常接受消息</li><li>可利用Run进行开启线程或者启动的时候利用一个列表开启线程池，很方便</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * File:   NonPreemptiveThreadPool.h</span></span><br><span class="line"><span class="comment"> * Author: zerber</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created on 2017年9月1日, 下午1:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"local_common/Public.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/base/Thread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/base/Mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/base/Condition.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/base/CountDownLatch.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NONPREEMPTIVETHREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NONPREEMPTIVETHREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> boost::function&lt;<span class="keyword">void</span> ()&gt; <span class="built_in">Task</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RunThreadNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    RunThreadNode(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,<span class="keyword">int</span> queuesize = <span class="number">0</span>):</span><br><span class="line">    countDownLatch_(<span class="number">1</span>),</span><br><span class="line">    listMutex_(),</span><br><span class="line">    blockMutex_(),</span><br><span class="line">    notEmpty_(listMutex_),</span><br><span class="line">    blockCond_(blockMutex_),</span><br><span class="line">    isBolck_(<span class="literal">false</span>),</span><br><span class="line">    threadName_(name),</span><br><span class="line">    thread_(boost::bind(&amp;RunThreadNode::RunInThread_,<span class="keyword">this</span>),threadName_),</span><br><span class="line">    running_(<span class="literal">false</span>),</span><br><span class="line">    queuesize_(queuesize)&#123;&#125;</span><br><span class="line">    ~RunThreadNode()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(running_)</span><br><span class="line">        &#123;</span><br><span class="line">            ThreadStop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PushTaskInQueue</span><span class="params">(<span class="keyword">const</span> <span class="built_in">Task</span>&amp; task)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ThreadStart</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ThreadStop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">GetThreadName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ThreadBlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ThreadWakeUp</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    muduo::CountDownLatch countDownLatch_;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">Task</span> <span class="title">Take_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RunInThread_</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    muduo::MutexLock listMutex_;</span><br><span class="line">    muduo::MutexLock blockMutex_;</span><br><span class="line">    muduo::Condition notEmpty_;</span><br><span class="line">    muduo::Condition blockCond_;</span><br><span class="line">    <span class="keyword">bool</span> isBolck_;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> threadName_;</span><br><span class="line"></span><br><span class="line">    muduo::Thread thread_;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">Task</span>&gt; queue_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> running_;</span><br><span class="line">    <span class="keyword">int</span> queuesize_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> boost::<span class="built_in">shared_ptr</span>&lt;RunThreadNode&gt; RunThreadNodePtr;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonPreemptiveThreadPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//指定队列长度，指定生成哪些线程</span></span><br><span class="line">    NonPreemptiveThreadPool(<span class="keyword">int</span> queuesize,</span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</span><br><span class="line">            <span class="keyword">int</span>* threadList,</span><br><span class="line">            <span class="keyword">int</span> threadListNum);</span><br><span class="line">    ~NonPreemptiveThreadPool();  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">(<span class="keyword">int</span> threadNum, <span class="keyword">const</span> <span class="built_in">Task</span>&amp; f)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">(<span class="keyword">int</span> threadNum)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AllStart</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AllStop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ThreadBlock</span><span class="params">(<span class="keyword">int</span> threadNum)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ThreadWakeUp</span><span class="params">(<span class="keyword">int</span> threadNum)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">    boost::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, RunThreadNodePtr&gt; threads_;</span><br><span class="line">    <span class="keyword">int</span> queuesize_;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* NONPREEMPTIVETHREADPOOL_H */</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * File:   NonPreemptiveThreadPool.cpp</span></span><br><span class="line"><span class="comment"> * Author: zerber</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created on 2017年9月1日, 下午1:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"NonPreemptiveThreadPool.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;muduo/base/Exception.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunThreadNode::PushTaskInQueue</span><span class="params">(<span class="keyword">const</span> <span class="built_in">Task</span>&amp; task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">muduo::MutexLockGuard <span class="title">lock</span><span class="params">(listMutex_)</span></span>;</span><br><span class="line">    </span><br><span class="line">    queue_.push(task);</span><br><span class="line">    notEmpty_.notify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunThreadNode::ThreadStart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    running_ = <span class="literal">true</span>;</span><br><span class="line">    thread_.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunThreadNode::ThreadStop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">muduo::MutexLockGuard <span class="title">lock</span><span class="params">(listMutex_)</span></span>;</span><br><span class="line">        running_ = <span class="literal">false</span>;</span><br><span class="line">        notEmpty_.notify();</span><br><span class="line">    &#125;</span><br><span class="line">    thread_.join();</span><br><span class="line">    </span><br><span class="line">    LOG_DEBUG &lt;&lt; <span class="string">"thread "</span> &lt;&lt; threadName_ &lt;&lt; <span class="string">" stop"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">RunThreadNode::GetThreadName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> threadName_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunThreadNode::ThreadBlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    isBolck_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunThreadNode::ThreadWakeUp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isBolck_)</span><br><span class="line">    &#123;</span><br><span class="line">        isBolck_ = <span class="literal">false</span>;</span><br><span class="line">        blockCond_.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">Task</span> <span class="title">RunThreadNode::Take_</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">muduo::MutexLockGuard <span class="title">lock</span><span class="params">(listMutex_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(queue_.empty() &amp;&amp; running_)</span><br><span class="line">    &#123;</span><br><span class="line">        notEmpty_.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Task</span> task;</span><br><span class="line">    <span class="keyword">if</span>(!queue_.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        task = queue_.front();</span><br><span class="line">        queue_.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunThreadNode::RunInThread_</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">muduo::MutexLockGuard <span class="title">lock</span><span class="params">(blockMutex_)</span></span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (running_)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="function"><span class="built_in">Task</span> <span class="title">task</span><span class="params">(Take_())</span></span>;</span><br><span class="line">          <span class="keyword">while</span>(isBolck_)</span><br><span class="line">          &#123;</span><br><span class="line">              blockCond_.wait();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(task)</span><br><span class="line">          &#123;</span><br><span class="line">            task();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> muduo::Exception&amp; ex)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"exception caught in ThreadPool %s\n"</span>, threadName_.c_str());</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"reason: %s\n"</span>, ex.what());</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"stack trace: %s\n"</span>, ex.stackTrace());</span><br><span class="line">      <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception&amp; ex)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"exception caught in ThreadPool %s\n"</span>, threadName_.c_str());</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"reason: %s\n"</span>, ex.what());</span><br><span class="line">      <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"unknown exception caught in ThreadPool %s\n"</span>, threadName_.c_str());</span><br><span class="line">      <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">NonPreemptiveThreadPool::NonPreemptiveThreadPool(<span class="keyword">int</span> queuesize, </span><br><span class="line">                                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</span><br><span class="line">                                                 <span class="keyword">int</span>* threadList = <span class="literal">NULL</span>, </span><br><span class="line">                                                 <span class="keyword">int</span> threadListNum = <span class="number">0</span>)</span><br><span class="line">:queuesize_(queuesize),</span><br><span class="line">name_(name)        </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(threadList != <span class="literal">NULL</span> &amp;&amp; threadListNum &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;threadListNum ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> id[<span class="number">32</span>];</span><br><span class="line">            <span class="built_in">snprintf</span>(id, <span class="keyword">sizeof</span>(id), <span class="string">"%d"</span>, threadList[i]);</span><br><span class="line">            RunThreadNodePtr pCurRunThreadNode = boost::make_shared&lt;RunThreadNode&gt;(name_+id,queuesize_);</span><br><span class="line">            threads_.insert(make_pair(threadList[i],pCurRunThreadNode));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NonPreemptiveThreadPool::~NonPreemptiveThreadPool()</span><br><span class="line">&#123;</span><br><span class="line">    AllStop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NonPreemptiveThreadPool::Run</span><span class="params">(<span class="keyword">int</span> threadNum, <span class="keyword">const</span> <span class="built_in">Task</span>&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> iter = threads_.<span class="built_in">find</span>(threadNum);</span><br><span class="line">    <span class="keyword">if</span>(iter != threads_.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        iter-&gt;second-&gt;PushTaskInQueue(f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> id[<span class="number">32</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(id, <span class="keyword">sizeof</span>(id), <span class="string">"%d"</span>, threadNum);</span><br><span class="line">        RunThreadNodePtr pCurRunThreadNode = boost::make_shared&lt;RunThreadNode&gt;(name_+id,queuesize_);</span><br><span class="line">        threads_.insert(make_pair(threadNum,pCurRunThreadNode));</span><br><span class="line">        pCurRunThreadNode-&gt;ThreadStart();</span><br><span class="line">        LOG_DEBUG &lt;&lt; <span class="string">"thread "</span> &lt;&lt; pCurRunThreadNode-&gt;GetThreadName() &lt;&lt; <span class="string">" start"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NonPreemptiveThreadPool::Stop</span><span class="params">(<span class="keyword">int</span> threadNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> iter = threads_.<span class="built_in">find</span>(threadNum);</span><br><span class="line">    <span class="keyword">if</span>(iter == threads_.<span class="built_in">end</span>()) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    iter-&gt;second-&gt;ThreadStop();</span><br><span class="line">    LOG_DEBUG &lt;&lt; <span class="string">"thread "</span> &lt;&lt; iter-&gt;second-&gt;GetThreadName() &lt;&lt; <span class="string">" stop"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NonPreemptiveThreadPool::AllStart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> iter = threads_.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(; iter!=threads_.<span class="built_in">end</span>() ;iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        iter-&gt;second-&gt;ThreadStart();</span><br><span class="line">    &#125;</span><br><span class="line">    LOG_DEBUG &lt;&lt; <span class="string">"all threads has been start"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NonPreemptiveThreadPool::AllStop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> iter = threads_.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(; iter!=threads_.<span class="built_in">end</span>() ;iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        iter-&gt;second-&gt;ThreadStop();</span><br><span class="line">    &#125;</span><br><span class="line">    LOG_DEBUG &lt;&lt; <span class="string">"all threads has been stop"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NonPreemptiveThreadPool::ThreadBlock</span><span class="params">(<span class="keyword">int</span> threadNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> iter = threads_.<span class="built_in">find</span>(threadNum);</span><br><span class="line">    <span class="keyword">if</span>(iter == threads_.<span class="built_in">end</span>()) <span class="keyword">return</span>;</span><br><span class="line">    iter-&gt;second-&gt;ThreadBlock();</span><br><span class="line">    LOG_DEBUG &lt;&lt; <span class="string">"thread "</span> &lt;&lt; iter-&gt;second-&gt;GetThreadName() &lt;&lt; <span class="string">" block"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NonPreemptiveThreadPool::ThreadWakeUp</span><span class="params">(<span class="keyword">int</span> threadNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> iter = threads_.<span class="built_in">find</span>(threadNum);</span><br><span class="line">    <span class="keyword">if</span>(iter == threads_.<span class="built_in">end</span>()) <span class="keyword">return</span>;</span><br><span class="line">    iter-&gt;second-&gt;ThreadWakeUp();</span><br><span class="line">    LOG_DEBUG &lt;&lt; <span class="string">"thread "</span> &lt;&lt; iter-&gt;second-&gt;GetThreadName() &lt;&lt; <span class="string">" wake up"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nothing&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Muduo" scheme="https://lazzyrabbit.github.io/tags/Muduo/"/>
    
  </entry>
  
  <entry>
    <title>Muduo库的框架剖析及总结(三)</title>
    <link href="https://lazzyrabbit.github.io/2016/08/06/Muduo%E5%BA%93%E7%9A%84%E6%A1%86%E6%9E%B6%E5%89%96%E6%9E%90%E5%8F%8A%E6%80%BB%E7%BB%93(%E4%B8%89)/"/>
    <id>https://lazzyrabbit.github.io/2016/08/06/Muduo%E5%BA%93%E7%9A%84%E6%A1%86%E6%9E%B6%E5%89%96%E6%9E%90%E5%8F%8A%E6%80%BB%E7%BB%93(%E4%B8%89)/</id>
    <published>2016-08-06T13:59:56.000Z</published>
    <updated>2020-02-15T17:05:18.160Z</updated>
    
    <content type="html"><![CDATA[<p>有些人觉得我的博客口水话很多，嗯，我个人考虑了一下，可能我写东西确实没有那么高大上，口水话很多，但是我个人确实非常喜欢这种看着非常亲切的风格，其实我觉得还好，只要你能读懂我的博客就行！！！有问题和意见可以提，有问题可以相互探讨、留言，甚至在留言板骂我都行，对我个人也是一种鼓励吧，好了还是太多废话了！！！</p><a id="more"></a><p>我前面有说过把Muduo库分成大致四个模块，那么我们今天把Channel模块和Eventloop这两个模块给搞定吧</p><p>Channel我们前面说过了它是一个事件处理器，看看它的对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">boost::weak_ptr&lt;<span class="keyword">void</span>&gt; tie_;</span><br><span class="line"><span class="keyword">bool</span> tied_;</span><br><span class="line"><span class="keyword">bool</span> eventHandling_;</span><br><span class="line"><span class="keyword">bool</span> addedToLoop_;</span><br><span class="line"><span class="comment">//读处理的回调</span></span><br><span class="line">ReadEventCallback readCallback_;</span><br><span class="line">EventCallback writeCallback_;</span><br><span class="line">EventCallback closeCallback_;</span><br><span class="line">EventCallback errorCallback_;</span><br></pre></td></tr></table></figure><p>再看看它的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Channel::Channel(EventLoop* loop, <span class="keyword">int</span> fd__)</span><br><span class="line">  : loop_(loop),</span><br><span class="line">    fd_(fd__),</span><br><span class="line">    events_(<span class="number">0</span>),</span><br><span class="line">    revents_(<span class="number">0</span>),</span><br><span class="line">    index_(<span class="number">-1</span>),</span><br><span class="line">    logHup_(<span class="literal">true</span>),</span><br><span class="line">    tied_(<span class="literal">false</span>),</span><br><span class="line">    eventHandling_(<span class="literal">false</span>),</span><br><span class="line">    addedToLoop_(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们前面知道Acceptor和TcpConnection都用了Channel的<strong>setReadCallback</strong>，而这个函数呢就是相当于设置了Channel中的ReadBack回调函数，而这个ReadBack函数的作用是在Epoll一旦触发了就绪事件的回调函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setReadCallback</span><span class="params">(<span class="keyword">const</span> ReadEventCallback&amp; cb)</span></span></span><br><span class="line"><span class="function"></span>&#123; readCallback_ = cb; &#125;</span><br></pre></td></tr></table></figure><p>不过在这里强调的Channel则内的主要函数则不是这个<br>我们这里第一个应该强调的函数应该是：<br><strong>Channel::handleEvent</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用底下的处理事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::handleEvent</span><span class="params">(Timestamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  boost::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">void</span>&gt; guard;</span><br><span class="line">  <span class="keyword">if</span> (tied_)</span><br><span class="line">  &#123;</span><br><span class="line">    guard = tie_.lock();</span><br><span class="line">    <span class="keyword">if</span> (guard)</span><br><span class="line">    &#123;</span><br><span class="line">      handleEventWithGuard(receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    handleEventWithGuard(receiveTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而它的底层调用的是：<br><strong>Channel::handleEventWithGuard</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对各种事件的一个处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::handleEventWithGuard</span><span class="params">(Timestamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  eventHandling_ = <span class="literal">true</span>;</span><br><span class="line">  LOG_TRACE &lt;&lt; reventsToString();</span><br><span class="line">  <span class="keyword">if</span> ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (logHup_)</span><br><span class="line">    &#123;</span><br><span class="line">      LOG_WARN &lt;&lt; <span class="string">"Channel::handle_event() POLLHUP"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (closeCallback_) closeCallback_();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (revents_ &amp; POLLNVAL)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_WARN &lt;&lt; <span class="string">"Channel::handle_event() POLLNVAL"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (revents_ &amp; (POLLERR | POLLNVAL))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (errorCallback_) errorCallback_();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//读事件处理</span></span><br><span class="line">  <span class="keyword">if</span> (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (readCallback_) readCallback_(receiveTime);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//写事件处理</span></span><br><span class="line">  <span class="keyword">if</span> (revents_ &amp; POLLOUT)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (writeCallback_) writeCallback_();</span><br><span class="line">  &#125;</span><br><span class="line">  eventHandling_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实从这里我们能看出来这个函数其实是对当有就绪事件发生时判断事件是可读还是可写时间，判断完后调用一个可读事件函数或者一个可写事件函数，这是Channel中的最重要的一个函数，当然还有另一个重要的函数：<strong>void enableReading()</strong><br>在前面的TcpConnection中的<strong>TcpConnection::connectEstablished()</strong>我们调用过它，还有前面<strong>Acceptor</strong>中的<strong>Acceptor::listen()</strong>中我们也调用过它，我们这里就直接告诉它的功能了吧，就是起到一个注册事件的功能，我们来看一下它的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enableReading</span><span class="params">()</span> </span>&#123; events_ |= kReadEvent; update(); &#125;</span><br></pre></td></tr></table></figure><p>里面有个update()：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  addedToLoop_ = <span class="literal">true</span>;</span><br><span class="line">  loop_-&gt;updateChannel(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到它调用了Eventloop中的updateChannel()，虽然我们还没说到Eventloop，但是我们先走进去继续往下看吧，等后面说完Eventloop再来把之前的坑给补上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::updateChannel</span><span class="params">(Channel* channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert(channel-&gt;ownerLoop() == <span class="keyword">this</span>);</span><br><span class="line">  assertInLoopThread();</span><br><span class="line">  poller_-&gt;updateChannel(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到它又调用了一个<strong>poller**</strong>底下的updateChannel()<strong>(我想吐槽为什么封装那么多)，我们现在这里先不细说</strong>poller<strong>，因为它是一个抽象类，它会供我们去选择</strong>epoll<strong>或者</strong>poll**，我后面并没有分析poll的部分，而只是分析了epoll，直接进入epoll看就好咯：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EPollPoller::updateChannel</span><span class="params">(Channel* channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Poller::assertInLoopThread();</span><br><span class="line">  LOG_TRACE &lt;&lt; <span class="string">"fd = "</span> &lt;&lt; channel-&gt;fd() &lt;&lt; <span class="string">" events = "</span> &lt;&lt; channel-&gt;events();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> index = channel-&gt;index();</span><br><span class="line">  <span class="keyword">if</span> (index == kNew || index == kDeleted)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// a new one, add with EPOLL_CTL_ADD</span></span><br><span class="line">    <span class="keyword">int</span> fd = channel-&gt;fd();</span><br><span class="line">    <span class="keyword">if</span> (index == kNew)</span><br><span class="line">    &#123;</span><br><span class="line">      assert(channels_.<span class="built_in">find</span>(fd) == channels_.<span class="built_in">end</span>());</span><br><span class="line">      channels_[fd] = channel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// index == kDeleted</span></span><br><span class="line">    &#123;</span><br><span class="line">      assert(channels_.<span class="built_in">find</span>(fd) != channels_.<span class="built_in">end</span>());</span><br><span class="line">      assert(channels_[fd] == channel);</span><br><span class="line">    &#125;</span><br><span class="line">    channel-&gt;set_index(kAdded);</span><br><span class="line">    update(EPOLL_CTL_ADD, channel);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// update existing one with EPOLL_CTL_MOD/DEL</span></span><br><span class="line">    <span class="keyword">int</span> fd = channel-&gt;fd();</span><br><span class="line">    (<span class="keyword">void</span>)fd;</span><br><span class="line">    assert(channels_.<span class="built_in">find</span>(fd) != channels_.<span class="built_in">end</span>());</span><br><span class="line">    assert(channels_[fd] == channel);</span><br><span class="line">    assert(index == kAdded);</span><br><span class="line">    <span class="keyword">if</span> (channel-&gt;isNoneEvent())</span><br><span class="line">    &#123;</span><br><span class="line">      update(EPOLL_CTL_DEL, channel);</span><br><span class="line">      channel-&gt;set_index(kDeleted);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      update(EPOLL_CTL_MOD, channel);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后还是调用了一个EPollPoller::update()：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册删除事件核心</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EPollPoller::update</span><span class="params">(<span class="keyword">int</span> operation, Channel* channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">  bzero(&amp;event, <span class="keyword">sizeof</span> event);</span><br><span class="line">  event.events = channel-&gt;events();</span><br><span class="line">  event.data.ptr = channel;</span><br><span class="line">  <span class="keyword">int</span> fd = channel-&gt;fd();</span><br><span class="line">  <span class="comment">//核心</span></span><br><span class="line">  <span class="keyword">if</span> (::epoll_ctl(epollfd_, operation, fd, &amp;event) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (operation == EPOLL_CTL_DEL)</span><br><span class="line">    &#123;</span><br><span class="line">      LOG_SYSERR &lt;&lt; <span class="string">"epoll_ctl op="</span> &lt;&lt; operation &lt;&lt; <span class="string">" fd="</span> &lt;&lt; fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      LOG_SYSFATAL &lt;&lt; <span class="string">"epoll_ctl op="</span> &lt;&lt; operation &lt;&lt; <span class="string">" fd="</span> &lt;&lt; fd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，在这里你就能看到它实际上调用了<strong>epoll_ctl</strong>，所以无论是注册事件还是删除事件其实底层都是调用了这个函数，啊，这里说得有些深入Eventloop中了，待会说到这个地方，会把这里的一些坑给补上，这里我就要说明一点就是<strong>void enableReading()</strong>是一个注册事件的函数，而它底层调用指向Eventloop中的<strong>updateChannel()</strong>,我们一直往下深入就会发现实际上它调用了<strong>epoll_ctl</strong></p><hr><p>好吧Channel也说得差不多了，该说Eventloop这个家伙了，所谓的<strong>Eventloop</strong>在这里就类似于一个<strong>事件分流器</strong>，我们把我们所谓的一些事件封装成功能类，比如TcpConnection和Acceptor，当然这些事件有它们的文件描述符，OK！这个时候我们的<strong>Channel</strong>就相当于一个<strong>事件处理器</strong>，它把对于这个事件的一些方法收集在一起，当有就绪事件发生的时候，就会回调这些方法，我们把我们事件的文件描述符传入到Channel中，再将Channel放入到Eventloop中，那么剩下的事情就由Eventloop去处理吧</p><p>我们来看一下Eventloop这个类，它实际上是独立于TcpServer而存在，它，当然，我们只能说我们在结构上可以暂时这么说，因为当你建立一个Eventloop是独立创建然后传入指针进入TcpServer中的，而不是TcpServer创建好的，还是老规矩，老看一下它的成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> looping_; <span class="comment">/* atomic */</span></span><br><span class="line">  <span class="keyword">bool</span> quit_; <span class="comment">/* atomic and shared between threads, okay on x86, I guess. */</span></span><br><span class="line">  <span class="keyword">bool</span> eventHandling_; <span class="comment">/* atomic */</span></span><br><span class="line">  <span class="keyword">bool</span> callingPendingFunctors_; <span class="comment">/* atomic */</span></span><br><span class="line">  <span class="keyword">int64_t</span> iteration_;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">pid_t</span> threadId_;</span><br><span class="line">  Timestamp pollReturnTime_;<span class="comment">//时间戳</span></span><br><span class="line">  boost::scoped_ptr&lt;Poller&gt; poller_;<span class="comment">//底层的poll或者epoll</span></span><br><span class="line">  boost::scoped_ptr&lt;TimerQueue&gt; timerQueue_;<span class="comment">//时间队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Channel*&gt; ChannelList;</span><br><span class="line">  ChannelList activeChannels_;<span class="comment">//就绪事件</span></span><br><span class="line">  Channel* currentActiveChannel_;<span class="comment">//当前就绪事件</span></span><br></pre></td></tr></table></figure><p>构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">EventLoop::EventLoop()</span><br><span class="line">  : looping_(<span class="literal">false</span>),</span><br><span class="line">    quit_(<span class="literal">false</span>),</span><br><span class="line">    eventHandling_(<span class="literal">false</span>),</span><br><span class="line">    callingPendingFunctors_(<span class="literal">false</span>),</span><br><span class="line">    iteration_(<span class="number">0</span>),</span><br><span class="line">    threadId_(CurrentThread::tid()),</span><br><span class="line">    poller_(Poller::newDefaultPoller(<span class="keyword">this</span>)),<span class="comment">//选择poll或者epoll</span></span><br><span class="line">    timerQueue_(<span class="keyword">new</span> TimerQueue(<span class="keyword">this</span>)),<span class="comment">//epoll_wait的时间列表</span></span><br><span class="line">    wakeupFd_(createEventfd()),<span class="comment">//线程间通信需要的fd</span></span><br><span class="line">    wakeupChannel_(<span class="keyword">new</span> Channel(<span class="keyword">this</span>, wakeupFd_)),</span><br><span class="line">    currentActiveChannel_(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...貌似应该和ioloop有关，跟主线程和线程之间的响应有关</span></span><br><span class="line">  wakeupChannel_-&gt;setReadCallback(</span><br><span class="line">      boost::bind(&amp;EventLoop::handleRead, <span class="keyword">this</span>));</span><br><span class="line">  <span class="comment">// we are always reading the wakeupfd</span></span><br><span class="line">  wakeupChannel_-&gt;enableReading();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好吧，其实它的重点是这个：<br><strong>poller_(Poller::newDefaultPoller(this))</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Poller* <span class="title">Poller::newDefaultPoller</span><span class="params">(EventLoop* loop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (::getenv(<span class="string">"MUDUO_USE_POLL"</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PollPoller(loop);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EPollPoller(loop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前我也说过，它是对I/O复用，poll和epoll的一个选择，我所选择的是epoll<br>epoll的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EPollPoller::EPollPoller(EventLoop* loop)</span><br><span class="line">  : Poller(loop),</span><br><span class="line">  <span class="comment">//构造一个epoll</span></span><br><span class="line">    epollfd_(::epoll_create1(EPOLL_CLOEXEC)),</span><br><span class="line">    events_(kInitEventListSize)</span><br></pre></td></tr></table></figure><p>我们能看到它调用了<strong>epoll_create</strong>，创建一个<strong>epoll事件队列</strong></p><p>我们再转回Eventloop中：<br>我们要知道Eventloop最重要的一个函数就是<strong>loop()</strong>，我们应该分析的是这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert(!looping_);</span><br><span class="line">  assertInLoopThread();</span><br><span class="line">  looping_ = <span class="literal">true</span>;</span><br><span class="line">  quit_ = <span class="literal">false</span>;  <span class="comment">// <span class="doctag">FIXME:</span> what if someone calls quit() before loop() ?</span></span><br><span class="line">  LOG_TRACE &lt;&lt; <span class="string">"EventLoop "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" start looping"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//quit这个其实和线程有点关系，当然你要了解更多详细的请去看陈硕的书= =！！</span></span><br><span class="line">  <span class="keyword">while</span> (!quit_)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">//前面其实我们有看到这就是一个就是就绪事件列表哦</span></span><br><span class="line">    activeChannels_.<span class="built_in">clear</span>();<span class="comment">//删除事件列表所有元素</span></span><br><span class="line">    pollReturnTime_ = poller_-&gt;poll(kPollTimeMs, &amp;activeChannels_);<span class="comment">//!!!最重要的函数(我们可以看到这里它把activeChannels_传了进去)</span></span><br><span class="line">    ++iteration_;</span><br><span class="line">    <span class="keyword">if</span> (Logger::logLevel() &lt;= Logger::TRACE)</span><br><span class="line">    &#123;</span><br><span class="line">      printActiveChannels();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO sort channel by priority</span></span><br><span class="line">    eventHandling_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (ChannelList::iterator it = activeChannels_.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//把传进去的activeChannels_的就绪事件提取出来</span></span><br><span class="line">        it != activeChannels_.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">      currentActiveChannel_ = *it;</span><br><span class="line">  <span class="comment">//根据就绪事件处理事件</span></span><br><span class="line">      currentActiveChannel_-&gt;handleEvent(pollReturnTime_);</span><br><span class="line">    &#125;</span><br><span class="line">    currentActiveChannel_ = <span class="literal">NULL</span>;</span><br><span class="line">    eventHandling_ = <span class="literal">false</span>;</span><br><span class="line">    doPendingFunctors();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LOG_TRACE &lt;&lt; <span class="string">"EventLoop "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" stop looping"</span>;</span><br><span class="line">  looping_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好吧poll这个函数比较重要，当然它是调用了<strong>EPollPoller::poll()</strong>，好吧来看看：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Timestamp <span class="title">EPollPoller::poll</span><span class="params">(<span class="keyword">int</span> timeoutMs, ChannelList* activeChannels)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//我们看到这里调用了epoll_wait，这里当然就是监听就绪事件的文件描述符了</span></span><br><span class="line">  <span class="keyword">int</span> numEvents = ::epoll_wait(epollfd_,</span><br><span class="line">                               &amp;*events_.<span class="built_in">begin</span>(),</span><br><span class="line">                               <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(events_.<span class="built_in">size</span>()),</span><br><span class="line">                               timeoutMs);</span><br><span class="line">  <span class="keyword">int</span> savedErrno = errno;</span><br><span class="line">  <span class="function">Timestamp <span class="title">now</span><span class="params">(Timestamp::now())</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (numEvents &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_TRACE &lt;&lt; numEvents &lt;&lt; <span class="string">" events happended"</span>;</span><br><span class="line">    <span class="comment">//将就绪事件放入就绪队列拉到Eventloop中统一处理</span></span><br><span class="line">    fillActiveChannels(numEvents, activeChannels);</span><br><span class="line">    <span class="keyword">if</span> (implicit_cast&lt;<span class="keyword">size_t</span>&gt;(numEvents) == events_.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      events_.resize(events_.<span class="built_in">size</span>()*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (numEvents == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">" nothing happended"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// error happens, log uncommon ones</span></span><br><span class="line">    <span class="keyword">if</span> (savedErrno != EINTR)</span><br><span class="line">    &#123;</span><br><span class="line">      errno = savedErrno;</span><br><span class="line">      LOG_SYSERR &lt;&lt; <span class="string">"EPollPoller::poll()"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fillActiveChannels(numEvents, activeChannels)</strong>这个得看一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将就绪事件放到activeChannels中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EPollPoller::fillActiveChannels</span><span class="params">(<span class="keyword">int</span> numEvents,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     ChannelList* activeChannels)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert(implicit_cast&lt;<span class="keyword">size_t</span>&gt;(numEvents) &lt;= events_.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numEvents; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">//将就绪事件取出来放入到就绪事件列表中</span></span><br><span class="line">    Channel* channel = <span class="keyword">static_cast</span>&lt;Channel*&gt;(events_[i].data.ptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="keyword">int</span> fd = channel-&gt;fd();</span><br><span class="line">    ChannelMap::const_iterator it = channels_.<span class="built_in">find</span>(fd);</span><br><span class="line">    assert(it != channels_.<span class="built_in">end</span>());</span><br><span class="line">    assert(it-&gt;second == channel);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    channel-&gt;set_revents(events_[i].events);</span><br><span class="line">    activeChannels-&gt;push_back(channel);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实可以看到这就是一个提取就绪事件的一个过程，我们把就绪事件放入到activeChannels中，在Eventloop中再把从epoll中提取到的事件提取出来 ，并调用了currentActiveChannel_的handleEvent,而我们在分析Channel的时候我们已经分析了handleEvent的作用，那么实际上这里就相当于有就绪事件然后返回调用它的回调函数了，嗯，就是这么一个过程！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有些人觉得我的博客口水话很多，嗯，我个人考虑了一下，可能我写东西确实没有那么高大上，口水话很多，但是我个人确实非常喜欢这种看着非常亲切的风格，其实我觉得还好，只要你能读懂我的博客就行！！！有问题和意见可以提，有问题可以相互探讨、留言，甚至在留言板骂我都行，对我个人也是一种鼓励吧，好了还是太多废话了！！！&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Muduo" scheme="https://lazzyrabbit.github.io/tags/Muduo/"/>
    
  </entry>
  
  <entry>
    <title>Muduo库的框架剖析及总结(二)</title>
    <link href="https://lazzyrabbit.github.io/2016/08/06/Muduo%E5%BA%93%E7%9A%84%E6%A1%86%E6%9E%B6%E5%89%96%E6%9E%90%E5%8F%8A%E6%80%BB%E7%BB%93(%E4%BA%8C)/"/>
    <id>https://lazzyrabbit.github.io/2016/08/06/Muduo%E5%BA%93%E7%9A%84%E6%A1%86%E6%9E%B6%E5%89%96%E6%9E%90%E5%8F%8A%E6%80%BB%E7%BB%93(%E4%BA%8C)/</id>
    <published>2016-08-06T05:41:46.000Z</published>
    <updated>2020-02-15T15:57:20.354Z</updated>
    
    <content type="html"><![CDATA[<p>我觉得可能由于我可能要分析完这几个大的模块可能并非易事，要仔细的分析也是绝壁很困难，我写的文章带有很多的口水话，一方面我是希望用通俗的语言去解释这些东西大家能更加好的去理解，另一面可以让我自己更加方便在日后看的时候不至于蒙了</p><a id="more"></a><p>上次我们已经介绍完了TcpServer这个大类，诶这个大类啊还真是一个非常犀利的一个类呢，小小一个类把服务器改做的事情的接口全部都封装得完美无缺，那么现在我觉得应该介绍一下TcpConnection和Acceptor这两个大类了</p><p>我们先从TcpConnection这个大类开始说吧，我们前面说过，我们在Acceptor中设置了一个回调函数调用了TcpServer中的newconnection这个函数，不知道大家还有印象没</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  acceptor_-&gt;setNewConnectionCallback(</span><br><span class="line">      boost::bind(&amp;TcpServer::newConnection, <span class="keyword">this</span>, _1, _2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这里也新建了一个新的<strong>Tcpconnection</strong>了，那我们就进<strong>Tcpconnection</strong>中去看一下<br>首先还是看它内部的成员变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">EventLoop* loop_;&#x2F;&#x2F;事件处理器指针</span><br><span class="line">const string name_;</span><br><span class="line">StateE state_;  &#x2F;&#x2F; FIXME: use atomic variable</span><br><span class="line">&#x2F;&#x2F; we don&#39;t expose those classes to client.</span><br><span class="line">boost::scoped_ptr&lt;Socket&gt; socket_;</span><br><span class="line">boost::scoped_ptr&lt;Channel&gt; channel_;&#x2F;&#x2F;封装了一个事件处理器</span><br><span class="line">const InetAddress localAddr_;&#x2F;&#x2F;端口号什么的</span><br><span class="line">const InetAddress peerAddr_;</span><br><span class="line">ConnectionCallback connectionCallback_;&#x2F;&#x2F;连接回调</span><br><span class="line">MessageCallback messageCallback_;&#x2F;&#x2F;信息回调</span><br><span class="line">WriteCompleteCallback writeCompleteCallback_;</span><br><span class="line">HighWaterMarkCallback highWaterMarkCallback_;</span><br><span class="line">CloseCallback closeCallback_;</span><br><span class="line">size_t highWaterMark_;</span><br><span class="line">Buffer inputBuffer_;</span><br><span class="line">Buffer outputBuffer_; &#x2F;&#x2F; FIXME: use list&lt;Buffer&gt; as output buffer.</span><br><span class="line">boost::any context_;</span><br></pre></td></tr></table></figure><p>说句实在话，我觉得这里除了<strong>EventLoop</strong>、<strong>Channel</strong>、<strong>ConnectionCallback</strong>、<strong>MessageCallback</strong> 可以讨论一下，其它信息都跟主框架没有什么直接关系，哦，对了，还有个<strong>Buffer</strong>是起到缓冲区的作用</p><p>前面我们有过说在<strong>TcpServer::newConnection</strong>中调用了一个<strong>TcpConnection::connectEstablished</strong>函数，其实现在我们可以先来看一下这个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;有连接来的时候创建(顺带调用一下回调函数)</span><br><span class="line">void TcpConnection::connectEstablished()</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  assert(state_ &#x3D;&#x3D; kConnecting);</span><br><span class="line">  setState(kConnected);</span><br><span class="line">  channel_-&gt;tie(shared_from_this());</span><br><span class="line">  channel_-&gt;enableReading();</span><br><span class="line"></span><br><span class="line">  connectionCallback_(shared_from_this());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到它中间调用了一个比较重要的函数<strong>channel_-&gt;enableReading()</strong>，当然这个函数我们先记着，我暂时先告诉你们它的作用是注册时间，第二个它调用了<strong>connectionCallback_(shared_from_this())</strong>，这个我们也说过，在<strong>TcpServer::newConnection</strong>中它将connectionCallback和MessageCallback都注册了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conn-&gt;setConnectionCallback(connectionCallback_);</span><br><span class="line">conn-&gt;setMessageCallback(messageCallback_);</span><br></pre></td></tr></table></figure><p>当然它又用同样的方式注册Channel事件中的回调函数，当然这个注册的过程在TcpConnection中的构造函数上咯：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">TcpConnection::TcpConnection(EventLoop* loop,</span><br><span class="line">                             <span class="keyword">const</span> <span class="built_in">string</span>&amp; nameArg,</span><br><span class="line">                             <span class="keyword">int</span> sockfd,</span><br><span class="line">                             <span class="keyword">const</span> InetAddress&amp; localAddr,</span><br><span class="line">                             <span class="keyword">const</span> InetAddress&amp; peerAddr)</span><br><span class="line">  : loop_(CHECK_NOTNULL(loop)),</span><br><span class="line">    name_(nameArg),</span><br><span class="line">    state_(kConnecting),</span><br><span class="line">    socket_(<span class="keyword">new</span> Socket(sockfd)),</span><br><span class="line">    channel_(<span class="keyword">new</span> Channel(loop, sockfd)),</span><br><span class="line">    localAddr_(localAddr),</span><br><span class="line">    peerAddr_(peerAddr),</span><br><span class="line">    highWaterMark_(<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line">  channel_-&gt;setReadCallback(</span><br><span class="line">      boost::bind(&amp;TcpConnection::handleRead, <span class="keyword">this</span>, _1));</span><br><span class="line">  channel_-&gt;setWriteCallback(</span><br><span class="line">      boost::bind(&amp;TcpConnection::handleWrite, <span class="keyword">this</span>));</span><br><span class="line">  channel_-&gt;setCloseCallback(</span><br><span class="line">      boost::bind(&amp;TcpConnection::handleClose, <span class="keyword">this</span>));</span><br><span class="line">  channel_-&gt;setErrorCallback(</span><br><span class="line">      boost::bind(&amp;TcpConnection::handleError, <span class="keyword">this</span>));</span><br><span class="line">  LOG_DEBUG &lt;&lt; <span class="string">"TcpConnection::ctor["</span> &lt;&lt;  name_ &lt;&lt; <span class="string">"] at "</span> &lt;&lt; <span class="keyword">this</span></span><br><span class="line">            &lt;&lt; <span class="string">" fd="</span> &lt;&lt; sockfd;</span><br><span class="line">  socket_-&gt;setKeepAlive(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们还知道Tcpconnection中还有好几个send()函数，当然，你要知道它们实际上是重载了，这些send()是回复给客户端用的了，在这里我就不想再具体介绍了</p><p>下一个TcpConnection中比较重要的函数就是<strong>TcpConnection::handleRead</strong>了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleRead</span><span class="params">(Timestamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  <span class="keyword">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//此处调用了Buffer回调，这里会直接将readcv中得到的数据放入自己的Buffer中</span></span><br><span class="line">  <span class="keyword">ssize_t</span> n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">//此处调用了信息回调</span></span><br><span class="line">    messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    handleClose();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    errno = savedErrno;</span><br><span class="line">    LOG_SYSERR &lt;&lt; <span class="string">"TcpConnection::handleRead"</span>;</span><br><span class="line">    handleError();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们前面也看见了在构造函数中，它把<strong>TcpConnection::handleRead</strong>注册到了Channel中的ReadCallback中，至于怎么做哦，后期我们说到了Channel再探讨这个话题。</p><p>当然这个函数比较重要的两个地方还是：<br>1、<strong>ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);</strong>读取信息<br>2、<strong>messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);</strong>//这里的这个messageCallback当然是你可以自己编写内容的，就相当于逻辑处理由你自己处理，这个函数自己写，最后写成一个函数指针并用bind回调返回去调用这个你自己写的函数就好了。</p><hr><p>好了，对上面的地方我们就不要太过于去纠结了，接下来我们继续往下走，嗯接下来就说说Acceptor吧</p><p>呃，我认为还是应该先看看它的成员变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventLoop* loop_;  <span class="comment">//需要指向一个主线程事件分发器</span></span><br><span class="line">Socket acceptSocket_;  <span class="comment">//这个主要指的是监听socket</span></span><br><span class="line">Channel acceptChannel_;  <span class="comment">//这个主要指的是将监听事件放入到eventloop中</span></span><br><span class="line">NewConnectionCallback newConnectionCallback_;  <span class="comment">//创建一个新的连接，就此建立那么一个回调</span></span><br><span class="line"><span class="keyword">bool</span> listenning_;</span><br><span class="line"><span class="keyword">int</span> idleFd_;</span><br></pre></td></tr></table></figure><p>一个Eventloop指针，一个Socket对象，一个Channel事件对象，然后我们前面在TcpServer模块中说过newConnectionCallback_实际上就是TcpServer中的<strong>TcpServer::newConnection</strong></p><p>好吧，我们这个时候再来看一下它的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Acceptor::Acceptor(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; listenAddr, <span class="keyword">bool</span> reuseport)</span><br><span class="line">  : loop_(loop),</span><br><span class="line">    acceptSocket_(sockets::createNonblockingOrDie()),</span><br><span class="line">    acceptChannel_(loop, acceptSocket_.fd()),</span><br><span class="line">    listenning_(<span class="literal">false</span>),</span><br><span class="line">    idleFd_(::<span class="built_in">open</span>(<span class="string">"/dev/null"</span>, O_RDONLY | O_CLOEXEC))</span><br><span class="line">&#123;</span><br><span class="line">  assert(idleFd_ &gt;= <span class="number">0</span>);</span><br><span class="line">  acceptSocket_.setReuseAddr(<span class="literal">true</span>);</span><br><span class="line">  acceptSocket_.setReusePort(reuseport);<span class="comment">//端口重用，多个tcp可以绑定相同的端口</span></span><br><span class="line">  acceptSocket_.bindAddress(listenAddr);</span><br><span class="line">  acceptChannel_.setReadCallback(</span><br><span class="line">      boost::bind(&amp;Acceptor::handleRead, <span class="keyword">this</span>));<span class="comment">//在有可读的fd的时候调用ReadCallback</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到它调用了这么一个函数<strong>acceptSocket_(sockets::createNonblockingOrDie())</strong>，这个<strong>sockets::createNonblockingOrDie()</strong>到底是干嘛用的呢？待会我们介绍socket的时候我们会介绍到，这个还是比较重要的</p><p><strong>acceptChannel_(loop, acceptSocket_.fd())</strong>这个地方我们可以很明显的看出它启用了一个Channel对象，而这个Channel我在这里也可以说是跟监听socket相关</p><p><strong>acceptChannel_.setReadCallback(boost::bind(&amp;Acceptor::handleRead, this));</strong>我们在这里也可以看到handleRead封装进了Acceptor中的Channel中，跟TcpConnection的作法是一样的，这里后期我们再讨论它的重要性</p><p>前面我们说过调用newConnectionCallback_实际上就是调用了TcpServer中的<strong>TcpServer::newConnection</strong>，而我们什么时候调用它呢？那么就在我们刚刚所讨论到的HandleRead中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对读事件的处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Acceptor::handleRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  InetAddress peerAddr;</span><br><span class="line">  <span class="comment">//FIXME loop until no more</span></span><br><span class="line">  <span class="keyword">int</span> connfd = acceptSocket_.accept(&amp;peerAddr);</span><br><span class="line">  <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// string hostport = peerAddr.toIpPort();</span></span><br><span class="line">    <span class="comment">// LOG_TRACE &lt;&lt; "Accepts of " &lt;&lt; hostport;</span></span><br><span class="line">    <span class="keyword">if</span> (newConnectionCallback_)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//我们可以看到在这里它就调用了创建新的TcpConnection</span></span><br><span class="line">      newConnectionCallback_(connfd, peerAddr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      sockets::<span class="built_in">close</span>(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...中间我省略一些不要的东西</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里我们说除了看到它调用newConnectionCallback_外其实还有一个更重要的东西那就是<strong>acceptSocket_.accept(&amp;peerAddr)</strong>，我们可以现在在这里大致的说一下它的底层实际是调用了accept()函数，这个当然是当我们分析到Socket这个类的时候我会说的。</p><p>Acceptor还有一个比较重要的函数就是<strong>void Acceptor::listen()</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始调用listen进行监听，并且enableReading注册事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Acceptor::listen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  listenning_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">//底层调用了listen()函数</span></span><br><span class="line">  acceptSocket_.<span class="built_in">listen</span>();</span><br><span class="line">  <span class="comment">//注册事件到epoll上</span></span><br><span class="line">  acceptChannel_.enableReading();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实我想说Accepor这个类到这里就算分析完了！！！</p><hr><p>我们接下来继续往下走，这个才是Acceptor的核心，Socket类<br>其实在前面我们能看到Acceptor中的构造函数调用了这么一个Socket类中的函数：<br> <strong>acceptSocket_(sockets::createNonblockingOrDie())</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sockets::createNonblockingOrDie</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> VALGRIND</span></span><br><span class="line"><span class="comment">//创建一个监听socket</span></span><br><span class="line">  <span class="keyword">int</span> sockfd = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">  <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; <span class="string">"sockets::createNonblockingOrDie"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//把socket设置成非阻塞模式</span></span><br><span class="line">  setNonBlockAndCloseOnExec(sockfd);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> sockfd = ::socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, IPPROTO_TCP);</span><br><span class="line">  <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; <span class="string">"sockets::createNonblockingOrDie"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们把设置监听socket找到了<br>还调用了那么一个函数：<br> <strong>acceptSocket_.bindAddress(listenAddr)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Socket::bindAddress</span><span class="params">(<span class="keyword">const</span> InetAddress&amp; addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  sockets::bindOrDie(sockfd_, addr.getSockAddrInet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着继续往下走</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sockets::bindOrDie</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr_in&amp; addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = ::bind(sockfd, sockaddr_cast(&amp;addr), <span class="keyword">static_cast</span>&lt;<span class="keyword">socklen_t</span>&gt;(<span class="keyword">sizeof</span> addr));</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; <span class="string">"sockets::bindOrDie"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们把bind()找到了</p><p><strong>Acceptor::listen()</strong>中的listen调用了<strong>acceptSocket_.listen()</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Socket::listen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  sockets::listenOrDie(sockfd_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下走</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sockets::listenOrDie</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = ::<span class="built_in">listen</span>(sockfd, SOMAXCONN);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; <span class="string">"sockets::listenOrDie"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们把listen()找到了</p><p>从<strong>Acceptor::handleRead()</strong>中我们可以找到<strong>acceptSocket_.accept(&amp;peerAddr)</strong>，而这个函数的底层则是accpet()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket::accept</span><span class="params">(InetAddress* peeraddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">  bzero(&amp;addr, <span class="keyword">sizeof</span> addr);</span><br><span class="line">  <span class="comment">//找到accept()</span></span><br><span class="line">  <span class="keyword">int</span> connfd = sockets::accept(sockfd_, &amp;addr);</span><br><span class="line">  <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    peeraddr-&gt;setSockAddrInet(addr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> connfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是吧accept()找到了吧！！！<br>OK，我想说服务器最重要的几个函数我们都找到了<br>socket()、bind()、listen()、accept()，那么这一块也都算是分析完了吧！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我觉得可能由于我可能要分析完这几个大的模块可能并非易事，要仔细的分析也是绝壁很困难，我写的文章带有很多的口水话，一方面我是希望用通俗的语言去解释这些东西大家能更加好的去理解，另一面可以让我自己更加方便在日后看的时候不至于蒙了&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Muduo" scheme="https://lazzyrabbit.github.io/tags/Muduo/"/>
    
  </entry>
  
  <entry>
    <title>Muduo库的框架剖析及总结(一)</title>
    <link href="https://lazzyrabbit.github.io/2016/08/06/Muduo%E5%BA%93%E7%9A%84%E6%A1%86%E6%9E%B6%E5%89%96%E6%9E%90%E5%8F%8A%E6%80%BB%E7%BB%93(%E4%B8%80)/"/>
    <id>https://lazzyrabbit.github.io/2016/08/06/Muduo%E5%BA%93%E7%9A%84%E6%A1%86%E6%9E%B6%E5%89%96%E6%9E%90%E5%8F%8A%E6%80%BB%E7%BB%93(%E4%B8%80)/</id>
    <published>2016-08-06T02:58:53.000Z</published>
    <updated>2020-02-15T15:52:19.937Z</updated>
    
    <content type="html"><![CDATA[<p>话说回来呢，前段时间又重新看了一遍Muduo库，嗯哼，把原来的框架又大概走了一遍，嗯对，仅仅是框架，还有说到最精华的部分，我想说以前我是发过一篇对Muduo库的线程池的剖析（虽然说剖析的一般吧       =   =！！！，但是毕竟是自己的心血啊）。</p><a id="more"></a><p>Muduo库的内存池也是Muduo库精华的一部分，当然，还有一个精华的部分我认为是Muduo库的Buffer缓冲区，它运用了环形缓冲区以及vector制动拓长数组的这一个性质，这里觉得它运用的很巧妙有木有，WHY？我想说它这里的环形缓冲区既保持了解决黏包问题缓冲区不够的问题，同时vector又解决了缓冲区自动增长的问题，我想说陈硕在这方面考虑问题简直就是天才！！！</p><p>当然还有什么bind,function,shareptr,scoreptr,weakptr这些boost库的东西在Muduo库中也是巧妙的运用了，诶，陈硕简直天才，妈蛋啊，把C++简直运用得炉火纯青，淋漓尽致，呃，感觉说了好多屁话吧，接下来开始进入重点！！！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016/08/06/Muduo%E5%BA%93%E7%9A%84%E6%A1%86%E6%9E%B6%E5%89%96%E6%9E%90%E5%8F%8A%E6%80%BB%E7%BB%93(%E4%B8%80)/muduo.jpeg" alt="muduo" title>                </div>                <div class="image-caption">muduo</div>            </figure><p>好了好了，我们可以很明显的从图上看到我分了几个部分对吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">TcpServer  </span><br><span class="line">代表的是一个总的服务器的类，我们并不知道服务器内部大概要做什么，我们只需要调用这个TcpServer就可以了，我们可以理解成它是一个服务器入口吧。</span><br><span class="line"></span><br><span class="line">TcpConnection</span><br><span class="line">这里是一个连接处理器，当accept接受了一条连接的话就会在这里面进行处理</span><br><span class="line"></span><br><span class="line">Acceptor</span><br><span class="line">这里面是对Socket和一个Channel的一个一个封装，我想理解它为一个中间的处理器，当然我们必须把Socket算进来，因为毕竟Acceptor封装的是Socket</span><br><span class="line"></span><br><span class="line">Socket </span><br><span class="line">Socket本身是对socket、listen、bing、accept等服务器函数进行的一个封装</span><br><span class="line"></span><br><span class="line">Channel</span><br><span class="line">一个时间处理器，会把相关的对可读可写的事件处理函数回调放入这个类中形成一个对象，就是相当于对事件处理方法封装一下，假如epoll需要处理事件，会从Channel事件处理器中找到相应的方法对事件进行处理</span><br><span class="line"></span><br><span class="line">Eventloop  </span><br><span class="line">可以理解成为事件分流处理器，把相关的事件处理器Channel注册金epoll中，而假如epoll有反应则会调用Channle中相应的回调函数，Eventloop底层调用的是poll或者epoll</span><br><span class="line"></span><br><span class="line">Poll </span><br><span class="line">只是一个抽象类，作为对调用的Epoll或者Poll的基类</span><br><span class="line"></span><br><span class="line">EPollPoller</span><br><span class="line">Poll的子类，是调用的epoll的一个封装</span><br></pre></td></tr></table></figure><p>我们得把Muduo库分成四大块，分别是以<code>Acceptor</code>为主的服务器块，<code>TcpConnection</code>的连接块，<code>Channel</code>的事件块以及以<code>Eventloop</code>为主的epoll监听块。</p><p>我们先从Tcpserver来分析一下吧<br>看下TcpServer中的成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EventLoop* loop_;  &#x2F;&#x2F; the acceptor loop</span><br><span class="line">const string hostport_;  &#x2F;&#x2F;端口</span><br><span class="line">const string name_;  &#x2F;&#x2F;服务器名字吧</span><br><span class="line">boost::scoped_ptr&lt;Acceptor&gt; acceptor_; &#x2F;&#x2F; avoid revealing Acceptor  一个Acceptor对象</span><br><span class="line">boost::shared_ptr&lt;EventLoopThreadPool&gt; threadPool_; &#x2F;&#x2F;线程池</span><br><span class="line">ConnectionCallback connectionCallback_;  &#x2F;&#x2F;连接回调函数</span><br><span class="line">MessageCallback messageCallback_;  &#x2F;&#x2F;连接到信息的回调函数</span><br><span class="line">WriteCompleteCallback writeCompleteCallback_;</span><br><span class="line">ThreadInitCallback threadInitCallback_;</span><br><span class="line">AtomicInt32 started_;</span><br></pre></td></tr></table></figure><p>当然重要的成员对象我都写在上面了，有了注释。<br>我们再来看看<strong>TcpServer</strong>的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TcpServer::TcpServer(EventLoop* loop,</span><br><span class="line">                     const InetAddress&amp; listenAddr,</span><br><span class="line">                     const string&amp; nameArg,</span><br><span class="line">                     Option option)</span><br><span class="line">  : loop_(CHECK_NOTNULL(loop)),</span><br><span class="line">    hostport_(listenAddr.toIpPort()),</span><br><span class="line">    name_(nameArg),</span><br><span class="line">    acceptor_(new Acceptor(loop, listenAddr, option &#x3D;&#x3D; kReusePort)),</span><br><span class="line">    threadPool_(new EventLoopThreadPool(loop)),</span><br><span class="line">    connectionCallback_(defaultConnectionCallback),</span><br><span class="line">    messageCallback_(defaultMessageCallback),</span><br><span class="line">    nextConnId_(1)</span><br><span class="line">&#123;</span><br><span class="line">  acceptor_-&gt;setNewConnectionCallback(</span><br><span class="line">      boost::bind(&amp;TcpServer::newConnection, this, _1, _2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到传进来几个参数，分别是<strong>EventLoop、InetAddress、string、Option</strong><br>重点还是<strong>EventLoop</strong>和<strong>InetAddress</strong>，一个是事件分流器，而这个<strong>InetAddress</strong>呢则是对套接字地址<strong>sockaddr_in</strong>的一个封装，我们把端口号和要绑定的IP地址传进去即可。</p><p><strong>EventLoopThreadPool</strong>这家伙是个线程池，至于内部的结构希望看我对<strong>EventLoopThreadPool</strong>分析的那篇文章比较好吧。</p><p><strong>TcpServer</strong>内部封装了一个<strong>Accepror</strong>对象<strong>acceptor_</strong>，当然我们知道它是用<strong>scoped_ptr</strong>对它进行封装的了。</p><p><strong>ConnectionCallback connectionCallback_</strong>的作用是当accept接受到一个新的连接产生一个新的文件描述符而创造了一个通信套接字的时候，调用一下这个<strong>connectionCallback_</strong>回调函数，当然这个函数内容可以你自己设计，可以让你提取回调的<strong>TcpConnection</strong> 对象。</p><p><strong>MessageCallback messageCallback_</strong>的作用是当通信套接字接受到一个新的信息的时候进行回调，当然，这个回调函数的内容也可以你自己去设计。</p><p><strong>ConnectionCallback</strong>和<strong>MessageCallback</strong> 的回调函数的参数都有固定格式，在这里不是重点对象就不说了。</p><p>我们可以看到在构造函数中<strong>setNewConnectionCallback</strong>这个回调函数调用了<strong>TcpServer::newConnection</strong>，嗯哼，这是一个什么样的函数呢？我们来看一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void TcpServer::newConnection(int sockfd, const InetAddress&amp; peerAddr)</span><br><span class="line">&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  &#x2F;&#x2F;从io线程池中提取一条工作线程出来对accept的通信socket进行处理</span><br><span class="line">  EventLoop* ioLoop &#x3D; threadPool_-&gt;getNextLoop();</span><br><span class="line">  char buf[32];</span><br><span class="line">  snprintf(buf, sizeof buf, &quot;:%s#%d&quot;, hostport_.c_str(), nextConnId_);</span><br><span class="line">  ++nextConnId_;</span><br><span class="line">  string connName &#x3D; name_ + buf;</span><br><span class="line"></span><br><span class="line">  LOG_INFO &lt;&lt; &quot;TcpServer::newConnection [&quot; &lt;&lt; name_</span><br><span class="line">           &lt;&lt; &quot;] - new connection [&quot; &lt;&lt; connName</span><br><span class="line">           &lt;&lt; &quot;] from &quot; &lt;&lt; peerAddr.toIpPort();</span><br><span class="line">  InetAddress localAddr(sockets::getLocalAddr(sockfd));</span><br><span class="line">  &#x2F;&#x2F; FIXME poll with zero timeout to double confirm the new connection</span><br><span class="line">  &#x2F;&#x2F; FIXME use make_shared if necessary</span><br><span class="line">  &#x2F;&#x2F;我们能从这里看到它实际上是创建了一个TcpConnection，当accept接受到一个新的文件描述符的时候，创建一个TcpConnection对它进行封装</span><br><span class="line">   TcpConnectionPtr conn(new TcpConnection(ioLoop,</span><br><span class="line">                                          connName,</span><br><span class="line">                                          sockfd,</span><br><span class="line">                                          localAddr,</span><br><span class="line">                                          peerAddr));</span><br><span class="line">  &#x2F;&#x2F;我们可以从这里看出来是对新建立的TcpConnection的一些初始化</span><br><span class="line">  connections_[connName] &#x3D; conn;</span><br><span class="line">  conn-&gt;setConnectionCallback(connectionCallback_);</span><br><span class="line">  conn-&gt;setMessageCallback(messageCallback_);</span><br><span class="line">  conn-&gt;setWriteCompleteCallback(writeCompleteCallback_);</span><br><span class="line">  conn-&gt;setCloseCallback(</span><br><span class="line">      boost::bind(&amp;TcpServer::removeConnection, this, _1)); &#x2F;&#x2F; FIXME: unsafe</span><br><span class="line">  ioLoop-&gt;runInLoop(boost::bind(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，你可以从这里看到了啊，这个函数实际上是对accpet新接受到一个通信套接字以后把它放入到一个新创立的<strong>TcpConnection</strong>对这个通信套接字做一个封装，并将函数指针什么的初始化，诶对咯，它在最后还调用了一个<strong>TcpConnection::connectEstablished</strong>这个函数，后面介绍到<strong>TcpConnection</strong>的时候我们会来介绍一下这个函数的作用，在这里先大概介绍一下这个函数的作用就是将接受到的socket的文件描述符注册到epoll事件列表当中。</p><p>当然TcpServer中还有第二个比较重要的函数，这个函数代表了服务器的启动，这个函数当然就是<strong>void TcpServer::start()</strong>了，我们来简单的看一下这个函数的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void TcpServer::start()</span><br><span class="line">&#123;</span><br><span class="line">  if (started_.getAndSet(1) &#x3D;&#x3D; 0)</span><br><span class="line">  &#123;</span><br><span class="line">  &#x2F;&#x2F;对线程池的一个启动处理</span><br><span class="line">    threadPool_-&gt;start(threadInitCallback_);</span><br><span class="line"></span><br><span class="line">    assert(!acceptor_-&gt;listenning());</span><br><span class="line">    loop_-&gt;runInLoop(</span><br><span class="line">    &#x2F;&#x2F;当然这是调用了底层的listen监听咯</span><br><span class="line">    boost::bind(&amp;Acceptor::listen, get_pointer(acceptor_)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数启动了，底层的<strong>listen()</strong>函数就相当于启动了，所以我们可以暂时称这是一个服务器的开关</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;话说回来呢，前段时间又重新看了一遍Muduo库，嗯哼，把原来的框架又大概走了一遍，嗯对，仅仅是框架，还有说到最精华的部分，我想说以前我是发过一篇对Muduo库的线程池的剖析（虽然说剖析的一般吧       =   =！！！，但是毕竟是自己的心血啊）。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Muduo" scheme="https://lazzyrabbit.github.io/tags/Muduo/"/>
    
  </entry>
  
  <entry>
    <title>Nginx内存池的初步分析</title>
    <link href="https://lazzyrabbit.github.io/2016/08/04/Nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/"/>
    <id>https://lazzyrabbit.github.io/2016/08/04/Nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/</id>
    <published>2016-08-04T06:31:24.000Z</published>
    <updated>2020-02-12T16:37:37.348Z</updated>
    
    <content type="html"><![CDATA[<p>最近对Nginx进行了一些简单的剖析，要是剖析的不好希望大家见谅，本人水平有限哦</p><p>我们先看这么一副图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2016/08/04/Nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/nginx内存池数据结构逻辑图.jpeg" alt="nginx内存池数据结构逻辑图" title>                </div>                <div class="image-caption">nginx内存池数据结构逻辑图</div>            </figure><p>在调用这个图片之前我想先首先声明一下这幅图的作者啊，我可不想打着盗版的声音去用这幅图哦=   =！！！感谢这幅图的作者rainx！</p><p>好，下面我们来通过这个图来对整个内存池进行分析吧。<br>我们通过代码的对比来分析这幅图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存池头部结构 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_pool_data_t</span>       d;<span class="comment">//对线程块的一个管理</span></span><br><span class="line">    <span class="keyword">size_t</span>                <span class="built_in">max</span>;<span class="comment">//最大值</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>           *current;<span class="comment">//当前指针指的是哪个内存块</span></span><br><span class="line">    <span class="keyword">ngx_chain_t</span>          *chain;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>     *large;<span class="comment">//大块内存</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>   *cleanup;<span class="comment">//清除某些特殊数据</span></span><br><span class="line">    <span class="keyword">ngx_log_t</span>            *<span class="built_in">log</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实我觉得我们先应该通过这个结构体和这幅图来了解一下nginx内存池，其实所谓的一个内存池是通过一个链表来进行管理的，而ngx_pool_t就是对一个节点进行管理的结构体。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ngx_pool_data_t  d  &#x2F;&#x2F;这是对这一块ngx_pool_t的数据块的一个管理</span><br><span class="line">size_t  max  &#x2F;&#x2F;数据块的大小，也就是你所分配的这一块节点数据区域的大小</span><br><span class="line">ngx_pool_t  *current  &#x2F;&#x2F;当前可分配的ngx_pool_t</span><br><span class="line">ngx_pool_large_t     *large  &#x2F;&#x2F;大于max的用大块内存区域存储</span><br><span class="line">ngx_pool_cleanup_t   *cleanup  &#x2F;&#x2F;用于清除某些文件描述符或者其它的特殊结构</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    u_char               *last;<span class="comment">//当前内存池分配到此处，即下一次分配从此处开始</span></span><br><span class="line">    u_char               *<span class="built_in">end</span>;<span class="comment">//内存池结束位置</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>           *next;<span class="comment">//内存池里面有很多块内存，这些内存   </span></span><br><span class="line">                               <span class="comment">//块就是通过该指针连成链表的 </span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            failed;<span class="comment">//内存池分配失败次数</span></span><br><span class="line">&#125; <span class="keyword">ngx_pool_data_t</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u_char  *last  &#x2F;&#x2F;指向可以分配内存空间的地方，last实际上是作为已经分配的内存空间的末尾，而下一次数据分配就要从last开始到end，当然要是在分配的空间小于max的情况下，假如下一次所要求分配的空间大于max，那么则开辟大块内存</span><br><span class="line">u_char  *end  &#x2F;&#x2F;数据域最末尾的指针</span><br><span class="line">ngx_pool_t  *next  &#x2F;&#x2F;指向下一块ngx_pool_t，这是在内存分配不够，开辟了下一个ngx_pool_t的前提下</span><br><span class="line">ngx_uint_t  failed  &#x2F;&#x2F;假如我们的分配的内存空间过于的小，超过4次在此块ngx_pool_t分配不成功，那么我们的current就会指向下一个ngx_pool_t，这个就是记录失败次数的一个记录器</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;管理大块内存</span><br><span class="line">struct ngx_pool_large_s &#123;</span><br><span class="line">    ngx_pool_large_t     *next;&#x2F;&#x2F;下一块</span><br><span class="line">    void                 *alloc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们在这里强调一下，大块内存实际上是指在ngx_pool_t中大于max的需要分配的节点，当然每次分配都是在current节点中，ngx_pool_t中的large指针负责将这些节点串联起来<br>void  *alloc  //当然指的就是大块内存的分配区域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct ngx_pool_cleanup_s &#123;</span><br><span class="line">    ngx_pool_cleanup_pt   handler;&#x2F;&#x2F;处理特殊数据的回调函数</span><br><span class="line">    void                 *data;&#x2F;&#x2F;指向要清除的数据</span><br><span class="line">    ngx_pool_cleanup_t   *next;&#x2F;&#x2F;下一个cleanup callback  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然我想说这个结构体没啥好介绍的，当我们在内存池中加入打开了些文件描述符在释放前需要关闭这些文件描述符或者一些特殊结构需要释放的时候，我们会调用<strong>ngx_pool_cleanup_s</strong>中的<strong>handler</strong>函数，当然这也是一个节点，我们需要在处理这些特殊的结构或者文件描述符的时候用特定的回调函数handler，我们需要把这些handler串联起来，其实跟ngx_pool_large_s差不多，也是在当前的current下，而串联起来这些节点的是cleanup指针</p><hr><p>好啦，我能说nginx中内存池大致的结构我已经剖析完了，现在我们来分析一些对它的操作的函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_alloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_calloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ngx_pool_t</span> *<span class="title">ngx_create_pool</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_destroy_pool</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_reset_pool</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_palloc</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_pnalloc</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_pcalloc</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_pmemalign</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> alignment)</span></span>;</span><br></pre></td></tr></table></figure><p>咱们来一个个分析好吧:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">ngx_alloc(<span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>  *p;</span><br><span class="line"><span class="comment">//可以看出来底层调用了malloc</span></span><br><span class="line">    p = <span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno,</span><br><span class="line">                      <span class="string">"malloc(%uz) failed"</span>, <span class="built_in">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, <span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"malloc: %p:%uz"</span>, p, <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ngx_alloc</strong>我们可以把它看成一个底层调用函数，直接调用的malloc，当然这里是看起来跟内存池没有任何关系了，但是它应该算是内存池的底层调用函数</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">ngx_calloc(<span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>  *p;</span><br><span class="line"><span class="comment">//带清零作用的</span></span><br><span class="line">    p = ngx_alloc(<span class="built_in">size</span>, <span class="built_in">log</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        ngx_memzero(p, <span class="built_in">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里当然也是相当于一个底层调用函数，它只不过相当于从堆上分配了一块内存附带清零的作用，仅此而已</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ngx_pool_t *</span><br><span class="line">ngx_create_pool(size_t size, ngx_log_t *log)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_pool_t  *p;</span><br><span class="line"></span><br><span class="line">    p &#x3D; ngx_memalign(NGX_POOL_ALIGNMENT, size, log);</span><br><span class="line">    if (p &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;d.last &#x3D; (u_char *) p + sizeof(ngx_pool_t);</span><br><span class="line">    p-&gt;d.end &#x3D; (u_char *) p + size;</span><br><span class="line">    p-&gt;d.next &#x3D; NULL;</span><br><span class="line">    p-&gt;d.failed &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    size &#x3D; size - sizeof(ngx_pool_t);</span><br><span class="line">    p-&gt;max &#x3D; (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br><span class="line"></span><br><span class="line">    p-&gt;current &#x3D; p;</span><br><span class="line">    p-&gt;chain &#x3D; NULL;</span><br><span class="line">    p-&gt;large &#x3D; NULL;</span><br><span class="line">    p-&gt;cleanup &#x3D; NULL;</span><br><span class="line">    p-&gt;log &#x3D; log;</span><br><span class="line"></span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>诶嘿，这里就很奇怪啊，貌似没有用到上面的ngx_alloc()函数啊，不过没关系，我只能说它其实并没有调用ngx_alloc()这个接口，而它调用了另一个接口:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#x3D; ngx_memalign(NGX_POOL_ALIGNMENT, size, log);</span><br></pre></td></tr></table></figure><p>我们可以看到这个接口和上面的接口都不一样，那么可以进这个接口里面去看一下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">ngx_memalign(<span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>  *p;</span><br><span class="line">    <span class="keyword">int</span>    err;</span><br><span class="line"><span class="comment">//调用posix_memalign( )成功时会返回size字节的动态内存</span></span><br><span class="line"><span class="comment">//并且这块内存的地址是alignment的倍数</span></span><br><span class="line"><span class="comment">//参数alignment必须是2的幂，还是void指针的大小的倍数</span></span><br><span class="line">    err = posix_memalign(&amp;p, alignment, <span class="built_in">size</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它里面涵盖了一个叫做<strong>posix_memalign(&amp;p, alignment, size)</strong>的函数，那么这个函数的作用是干嘛的呢？我们知道POSIX标明了通过<strong>malloc(), calloc(), 和 realloc()</strong>返回的地址对于任何的C类型来说都是对齐的。在Linux中，这些函数返回的地址在32位系统是以8字节为边界对齐，在64位系统是以16字节为边界对齐的,而<strong>posix_memalign(&amp;p, alignment, size)</strong>的作用就是动态对齐。而在这里它则是按alignment大小来进行对齐的，其实也可以看一下这个玩意的大小吧:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define NGX_POOL_ALIGNMENT       16*</span><br></pre></td></tr></table></figure><p>嘿嘿，看到没有，它的大小是16哦！！！也就是说它是按16来进行对齐的，至于具体的posix_memalign(&amp;p, alignment, size)咋用，希望大家自己回去查一下吧。</p><p>当然我们也看过了ngx_memalign(…)函数，我们继续来看一下ngx_create_pool(…)函数，我们可以看到它对max进行了一个初始化:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;max &#x3D; (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br></pre></td></tr></table></figure><p>其实我一直很好奇这个地方啊，这个地方的max是经过传进来的值决定的，而假如，传进来的小于NGX_MAX_ALLOC_FROM_POOL，那么按size的大小来计算哦，这里我们再来顺带看一下NGX_MAX_ALLOC_FROM_POOL是什么:<br><strong>#define NGX_MAX_ALLOC_FROM_POOL  (ngx_pagesize - 1)</strong></p><p>对哦，这里是一个宏定义，定义的大小是4K-1个大小，那么我们姑且算在小于4K的情况下它按size大小来定义吧，其实我认为这里的唯一的好处就是它按分页机制去处理了一个最大内存，假如我不到4K我能节约性的从内存中拿合适的内存，当大于4K的时候我们就可以不考虑页面大小的问题了，直接就大块内存走起，当然，考不考虑4K不是我们说了算，而是刚开始申请的size大小说了算哦。</p><p>我一直觉得这个地方有个BUG，那就是假如传进来的size &lt; sizeof(ngx_pool_t)怎么办？不就成负数了？那么这个进程会不会因此挂掉？这个我就是不是很清楚了！！</p><hr><p>接下来看看<code>ngx_destroy_pool(ngx_pool_t *pool)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_destroy_pool</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>          *p, *n;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>    *l;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>  *c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先考虑cleanup函数，但是貌似我并没有找见有关的回调</span></span><br><span class="line">    <span class="keyword">for</span> (c = pool-&gt;cleanup; c; c = c-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler) &#123;</span><br><span class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                           <span class="string">"run cleanup: %p"</span>, c);</span><br><span class="line">            c-&gt;handler(c-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line"></span><br><span class="line">        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"free: %p"</span>, l-&gt;alloc);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">        <span class="keyword">for</span> (p = pool, n = pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        ngx_free(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以从这里看到它先调用了ngx_pool_t中的clean中的handler函数来清理一些它可能打开的文件描述符或者特殊结构，此时再free掉那些大块结构。当然，最后是把自己本身的节点给free掉了</p><hr><p><strong>void ngx_reset_pool(ngx_pool_t *pool)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ngx_reset_pool(<span class="keyword">ngx_pool_t</span> *pool)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>        *p;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>  *l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = pool; p; p = p-&gt;d.next) &#123;</span><br><span class="line">        p-&gt;d.last = (u_char *) p + <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_t</span>);</span><br><span class="line">        p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool-&gt;current = pool;</span><br><span class="line">    pool-&gt;chain = <span class="literal">NULL</span>;</span><br><span class="line">    pool-&gt;large = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数呢是内存池重置函数，它会将大块内存删掉并且把里面的东西给初始化哦！！</p><hr><p>下面说的就是<strong>void *ngx_palloc(ngx_pool_t *pool, size_t size)</strong>了吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">ngx_palloc</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>  *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &lt;= pool-&gt;<span class="built_in">max</span>) &#123;</span><br><span class="line"></span><br><span class="line">        p = pool-&gt;current;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            m = ngx_align_ptr(p-&gt;d.last, NGX_ALIGNMENT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">size_t</span>) (p-&gt;d.<span class="built_in">end</span> - m) &gt;= <span class="built_in">size</span>) &#123;</span><br><span class="line">                p-&gt;d.last = m + <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p = p-&gt;d.next;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ngx_palloc_block(pool, <span class="built_in">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ngx_palloc_large(pool, <span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到这里是从内存池中分配内存的一个函数，当我们前面创建好内存池之后，我们可以通过这里在一个ngx_pool_t中的数据段中分配节点，我们可以看到，它就只用了last和end两个标记位去标记剩余空间的大小，当我们空间大于max的时候直接用ngx_palloc_large(pool, size)调用大块内存，而假如小于max却在后面的ngx_pool_t中不够用的话则会调用ngx_palloc_block(pool, size)函数，其实内部就是重新申请了一块ngx_pool_t内存，调用的还是ngx_memalign(…)函数，有兴趣的朋友自己看看了。</p><p>当然后面还有一个<br><strong>void *ngx_pnalloc(ngx_pool_t *pool, size_t size);</strong><br>当然，这个函数和<strong>void *ngx_palloc(ngx_pool_t *pool, size_t size)</strong>最大的区别当然就是:<br><strong>void *ngx_palloc(ngx_pool_t *pool, size_t size)</strong>是对齐的<br><strong>void *ngx_palloc(ngx_pool_t *pool, size_t size)</strong>是不对齐的</p><hr><p>好了总结了那么多，觉得心好累啊！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近对Nginx进行了一些简单的剖析，要是剖析的不好希望大家见谅，本人水平有限哦&lt;/p&gt;
&lt;p&gt;我们先看这么一副图&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
  
      
    
    </summary>
    
    
    
      <category term="nginx" scheme="https://lazzyrabbit.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Time Check Failure 处理以及理解</title>
    <link href="https://lazzyrabbit.github.io/2016/04/21/%E5%AF%B9Run-Time%20Check%20Failure%20#3%E7%9A%84%E5%A4%84%E7%90%86%E4%BB%A5%E5%8F%8A%E7%90%86%E8%A7%A3/"/>
    <id>https://lazzyrabbit.github.io/2016/04/21/%E5%AF%B9Run-Time%20Check%20Failure%20#3%E7%9A%84%E5%A4%84%E7%90%86%E4%BB%A5%E5%8F%8A%E7%90%86%E8%A7%A3/</id>
    <published>2016-04-20T17:24:24.000Z</published>
    <updated>2020-02-10T16:24:35.900Z</updated>
    
    <content type="html"><![CDATA[<p>对 Run-Time Check Failure #3 - The variable ‘a’ is being used without being initialized 的处理以及理解</p><a id="more"></a><p>对于这个问题，我们先来看一个简单的C程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">48</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Fun1();</span><br><span class="line">    Fun2();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你们猜猜运行结果是什么？在VS下直接崩溃。。。<br>然后我又用VC和Linux下GCC测试，结果分别为-858993460和随机值。<br>于是。。。（懵逼）</p><p>通过分析，发现这与RTC（Run-Time Check，运行时检查）机制有关（以下都是以VS2012为标准）。</p><p>首先普及一下RTC（Run-Time Check）机制，包括<strong>堆栈帧（RTCS）</strong>、<strong>未初始化变量（RTCu）</strong>、<strong>两者都有</strong>、以及<strong>默认值</strong>四种。</p><p>在VS2012编译器中，项目-》属性-》配置属性-》C/C++ -》生成代码-》基本运行时检测 </p><ol><li><p>当开启RTCu（对未初始化变量运行时的检查）时，程序会崩溃。提示错误RTC Failure#3：使用了未初始化的变量。</p></li><li><p>当开启RTCs（对堆栈帧运行时的检查）时，可以运行，结果为固定值，针对以上程序，结果为-858993460（%d打印），0xcccccccc（%#x打印）。实际上调用Fun2()开辟新栈帧时，栈帧被0xcc初始化，打印出来的结果如上。</p></li><li><p>当两者都开启时，与情况一一样，程序崩溃。提示错误RTC Failure#3：使用了未初始化的变量</p></li><li><p>当使用默认值时，程序可以运行，结果为相对应位置的值。例如本程序中结果为48，若程序Fun1()函数中只有一个变量，值为多少，结果就为多少。说白了，函数Fun2()中变量a的值与其本身无关，而与相对应的内存中存放的值有关。原因是默认值这种模式，当有新的栈帧开辟时，不会有0xcc这个初始化的过程。</p></li></ol><p>以下为本人对如上问题的理解，如有偏颇，希望同仁批评指正，谢谢！</p><p>转载自:<strong><a href="http://blog.csdn.net/qq_29894329/article/details/51184920" target="_blank" rel="noopener">http://blog.csdn.net/qq_29894329/article/details/51184920</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对 Run-Time Check Failure #3 - The variable ‘a’ is being used without being initialized 的处理以及理解&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="c/c++" scheme="https://lazzyrabbit.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>linux下的多种调试方法</title>
    <link href="https://lazzyrabbit.github.io/2016/04/18/linux%E4%B8%8B%E7%9A%84%E5%A4%9A%E7%A7%8D%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    <id>https://lazzyrabbit.github.io/2016/04/18/linux%E4%B8%8B%E7%9A%84%E5%A4%9A%E7%A7%8D%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</id>
    <published>2016-04-17T17:22:02.000Z</published>
    <updated>2020-02-12T15:44:22.252Z</updated>
    
    <content type="html"><![CDATA[<p>linux下的多种调试方法</p><a id="more"></a><p>我们在写程序的时候肯定会遇到调试阶段，当程序在运行的时候，我们如何调试</p><p>当一个程序陷入死循环，我们又不想终止它，而还需要调试它<br>我们可以使用如下命令：   </p><p>1.首先查看运行进程的ID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -u</span><br></pre></td></tr></table></figure><p>2.接着</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动gdb attach +(进程号)</span><br></pre></td></tr></table></figure><p>这样我们就可以进行调试了</p><p>下来我们在看一种情况，如果gdb无法使用了怎们办呢？</p><p>我们可以使用<code>/proc</code>文件，它是一个伪目录，它仅在内存中，没有在磁盘上。</p><p>我们还可以使用<code>truss,strace,ltrace</code>调试工具来进行调试</p><p><strong>truss</strong> 和 <strong>strace</strong> 用来跟踪一个进程的系统调用 <strong>(fork,vfork,exec)</strong> 和信号产生的情况 <strong>ltrace</strong> 用来跟踪一个进程调用库函数的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-f:除了跟踪当前进程外，还跟踪子进程 fork</span><br><span class="line">-o file：将输出信息写到文件file中，</span><br><span class="line">-p pid：绑定到一个由pid对应的正在运行的进程中</span><br></pre></td></tr></table></figure><p><strong>转载自WILLBeSoSo的博客<br><a href="http://blog.sina.com.cn/s/blog_e017ce840102w9yr.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_e017ce840102w9yr.html</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux下的多种调试方法&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="linux" scheme="https://lazzyrabbit.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>关于Eventloopthreatpool的简单剖析</title>
    <link href="https://lazzyrabbit.github.io/2015/11/18/%E5%85%B3%E4%BA%8EEventloopthreatpool%E7%9A%84%E7%AE%80%E5%8D%95%E5%89%96%E6%9E%90/"/>
    <id>https://lazzyrabbit.github.io/2015/11/18/%E5%85%B3%E4%BA%8EEventloopthreatpool%E7%9A%84%E7%AE%80%E5%8D%95%E5%89%96%E6%9E%90/</id>
    <published>2015-11-18T07:05:58.000Z</published>
    <updated>2020-02-15T12:34:56.048Z</updated>
    
    <content type="html"><![CDATA[<p>最近对 muduo 库本身的 eventloopthreadpool 做了一个简单的剖析，写一个简单的总结，首先，我觉得简单介绍一下:</p><p>eventloopthreadpool 是基于 muduo 库中 Tcpserver 这个类专门做的一个线程池，它的模式属于半同步半异步，每一个线程中都有一个自己的 eventloop，而每一个 eventloop 底层都是一个 poll 或者 epoll，它利用了自身的 poll 或者 epoll 在没有时间的时候阻塞住，在有时间发生的时候，epoll 监听到了时间就会去处理事件。我们来画一下图，模式大概是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(轮询箭头)------&gt;|----------eventloopthread[0]--------Thread(处理)</span><br><span class="line">                |</span><br><span class="line">baseloop-------&gt;|-----eventloopthread[1]--------Thread(处理)</span><br><span class="line">(Accept)        |</span><br><span class="line">                |-----eventloopthread[2]--------Thread(处理)</span><br></pre></td></tr></table></figure><p>好，线程池的结构大概是这样子，说到这个线程池，我们首先不得不说一个玩意，互斥锁，在muduo库中，对互斥锁进行了很好的一个封装，我们来看一下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutexLockGuard</span> :</span> boost::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MutexLockGuard</span><span class="params">(MutexLock&amp; mutex)</span></span></span><br><span class="line"><span class="function">    : <span class="title">mutex_</span><span class="params">(mutex)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    mutex_.lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~MutexLockGuard()</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  MutexLock&amp; mutex_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这就是我说的互斥锁，这是对它进行的一层封装，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  MCHECK(pthread_mutex_lock(&amp;mutex_));</span><br><span class="line">  assignHolder();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  unassignHolder();</span><br><span class="line">  MCHECK(pthread_mutex_unlock(&amp;mutex_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我将它内部的代码展示出来大家可以很清楚的看到这是一个锁的封装了吧，这个锁最大的好处在于它比较智能，当我们创建它的时候，构造函数会自动帮我们生成一个锁，当我们在区域内，创造一个锁的时候，它会锁住，当出了这个区域的时候，锁自动解开。</p><p>现在我们来分析一下主要流程:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2015/11/18/%E5%85%B3%E4%BA%8EEventloopthreatpool%E7%9A%84%E7%AE%80%E5%8D%95%E5%89%96%E6%9E%90/eventloopthreadpool的结构图.jpeg" alt="eventloopthreadpool的结构图" title>                </div>                <div class="image-caption">eventloopthreadpool的结构图</div>            </figure><p>我们主要通过这个图去分析它的整体框架，看这个线程池到底做了个啥事，如何多个线程同时运作的。</p><p>我们先分析一下它的类中用到成员变量和每个类的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    MutexLock&amp; mutex_;<span class="comment">//锁</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> pcond_;<span class="comment">//条件变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoopThreadPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  EventLoop* baseLoop_; <span class="comment">//基于接受主线程socket的eventloop</span></span><br><span class="line">  <span class="keyword">bool</span> started_; <span class="comment">//线程池是否开始运作</span></span><br><span class="line">  <span class="keyword">int</span> numThreads_; <span class="comment">//线程的数量</span></span><br><span class="line">  boost::ptr_vector&lt;EventLoopThread&gt; threads_; <span class="comment">//线程池</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;EventLoop*&gt; loops_; <span class="comment">//线程池中的eventloop数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoopThread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  EventLoop* loop_; <span class="comment">//基于接受主线程socket的eventloop</span></span><br><span class="line">  Thread thread_; <span class="comment">//线程</span></span><br><span class="line">  MutexLock mutex_; <span class="comment">//锁</span></span><br><span class="line">  Condition cond_; <span class="comment">//条件变量</span></span><br><span class="line">  ThreadInitCallback callback_; <span class="comment">//外部参数以获得线程信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">pthread_t</span>  pthreadId_; <span class="comment">//线程ID</span></span><br><span class="line">  ThreadFunc func_; <span class="comment">//线程函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> muduo::Thread::ThreadFunc ThreadFunc;</span><br><span class="line">  ThreadFunc func_; <span class="comment">//线程函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看，它首先是从eventloopthreadpool中的start()这个函数当入口启动这个线程池的，内部有一个for循环，经过这个for循环就创建了一个线程池。</p><p>我们看，它创建了一个eventloop对象，并且把这个对象压入了eventloopthread的数组当中，并且提取出了它里面的eventloop压入了loops当中。</p><p>继续往下走，看下startloop干了个啥，是不是调用了一个thread.start()啊，底下加了个锁，锁底下的代码段是对主线程阻塞的一个判断，暂时先不理它。</p><p>继续往下走，进入thread中的start()，thread中的start()干了一件事，创建了一个ThreadData并且当做参数放入了线程函数当中，这个线程函数又是个啥玩意？是个startThread()对不对，接着进去，诶，有一个名叫runInThread()的函数，接着进入runInThread()，诶，发现了一些神奇的事，话不多说，上代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runInThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    func_();</span><br><span class="line">    muduo::CurrentThread::t_threadName = <span class="string">"finished"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>诶嘿，发现没有，这里调用了一个func_()，很眼熟吧，好像在前面见过，进入ThreadData的构造函数，func_()是啥，实质上是一个<strong>boost::function&lt; void () &gt;</strong>的函数回调指针。我们发现这里给func_()赋值,赋值也是外部传进来的，往回走，发现它调用的是Thread中start()的func_(),Thread中start()的func_()也是别人构造函数里面赋值的继续往前走，Eventloopthread在创建thread的时候给他赋了一个值，这个值就是 <strong>func_()</strong>，这个 func_() 实质上就是 Eventloop 中的 threadFunc()，诶，进去看一下，一个临时变量的Eventloop，先调用了一下 callback，先不理它，看后面，给Eventloop 中的loop_ 赋值，然后调用一个 notify()，往回看， notify()实质上就是一个 <strong>pthread_cond_signal(&amp;pcond_)</strong>，而我们之前Eventloop中看到有一个成员 Condition cond_ 这实际上就是对条件变量的一个封装。</p><p>此处有一个<strong>pthread_cond_signal</strong>，它要唤醒一个线程，唤醒哪个线程，诶这个不清楚，记得前面有一个cond_.wait() 对不对，它要唤醒这个cond_.wait()在startloop中，刚开始不知道它是干嘛的，现在知道了，当我们子线程创建的时候，它要创建一个eventloop啊，在还没保证它创建之前，我们的主线程不能继续往下创建新的线程，必须要等这个eventloop创建完成才能继续往下创建，因为eventloop才是这每一个线程的核心啊，当eventloop没创建完成时，我们会让其锁住，并让它成为阻塞状态，等到eventloop创建完成时，才会让主线程继续运行，继续创建下一个。</p><p>往下走你会发现它调用了<strong>loop.loop()</strong>，实质上调用了 poll 或者epoll ，利用其自身的阻塞性将线程给阻塞住了。</p><p>当我们完成这一步以后，我们还得回归一下前面一个地方，值得注意的地方就是在eventloopthreadpool中，它把每一个eventloop都提取出来放到一个数组loops中了，这样我们在提取它的loop是更方便了不是吗？</p><p>看到这我们大概会明白它的创建机制了吧。</p><p>创建好了要将其使用，咋用，话不多说上代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> InetAddress&amp; peerAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"> EventLoop* ioLoop = threadPool_-&gt;getNextLoop();</span><br><span class="line"> <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(ioLoop,connName,sockfd,localAddr,peerAddr);</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  connections_[connName] = conn;</span></span></span><br><span class="line"><span class="function"><span class="params">  conn-&gt;setConnectionCallback(connectionCallback_);</span></span></span><br><span class="line"><span class="function"><span class="params">  conn-&gt;setMessageCallback(messageCallback_);</span></span></span><br><span class="line"><span class="function"><span class="params">  conn-&gt;setWriteCompleteCallback(writeCompleteCallback_);</span></span></span><br><span class="line"><span class="function"><span class="params">  conn-&gt;setCloseCallback(</span></span></span><br><span class="line"><span class="function"><span class="params">      boost::bind(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, _1)); <span class="comment">// <span class="doctag">FIXME:</span> unsafe</span></span></span></span><br><span class="line"><span class="function"><span class="params">  ioLoop-&gt;runInLoop(boost::bind(&amp;TcpConnection::connectEstablished, conn));</span></span></span><br><span class="line"><span class="function"><span class="params"> &#125;</span></span></span><br></pre></td></tr></table></figure><p>这是TcpServer中的TcpServer::newConnection()，调用了<strong>threadPool_-&gt;getNextLoop()</strong> ，当我们分析过muduo库我们会知道，当TcpServer中的主线程每收到一个新的socket的时候，我们就将socket时间放到子线程中的eventloop中去处理，也就是说不同的子线程中的eventloop会有不同的socket，当我们不同的socket接受到消息的时候会在不同的子线程中同时处理，也就是说这样就大大提高了效率。</p><p>我们进<strong>threadPool_-&gt;getNextLoop()</strong> 中看看，我们会发现，它是轮询的调用eventloop的，也就是说主线程分配的socket是轮询进入不同的eventloop中的。</p><p><strong>最后再总结一下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、eventloopthreadpool是一个半同步半异步的机制</span><br><span class="line">2、eventloopthreadpool实际上是其中包含了一个eventloopthread的数组，而每一个eventloopthread对象实际上都管理着一个Thread，而每一个Thread对象实际上就是对一个线程的封装</span><br><span class="line">3、每一个eventloopthread对应一个线程，每一个eventloopthread又包含一个eventloop，也就是相当于一个线程对应一个eventloop，在不同的线程操作着不同的eventloop，实际上就是同时操作不同的poll或者epoll，效率大大的提高了</span><br><span class="line">4、当我们从主线程的eventloop中的Accept中listen到一个新的socket后轮询的发给每一个eventloop中，交由不同的eventloop去处理</span><br><span class="line">5、它实质上的线程函数是void EventLoopThread::threadFunc()</span><br><span class="line">6、值得注意的一点是eventloop在每个线程中的loop还没有创建出来之前会阻塞住主线程，而在loop创建出来之后主线程释放，运行到下面loop.loop()后，会利用poll或者epoll自身的阻塞将线程阻塞住并进入循环接受消息的状态(PS:线程池每一条线程在不用的时候自身都必须进入阻塞状态，否则线程运行完就会释放了，线程池也就没什么意义了)，下面的loop_ &#x3D; NULL;也就不会执行了。</span><br></pre></td></tr></table></figure><p>好了，大概就是总结了那么多。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近对 muduo 库本身的 eventloopthreadpool 做了一个简单的剖析，写一个简单的总结，首先，我觉得简单介绍一下:&lt;/p&gt;
&lt;p&gt;eventloopthreadpool 是基于 muduo 库中 Tcpserver 这个类专门做的一个线程池，它的模式属于
      
    
    </summary>
    
    
    
      <category term="Muduo" scheme="https://lazzyrabbit.github.io/tags/Muduo/"/>
    
  </entry>
  
</feed>
