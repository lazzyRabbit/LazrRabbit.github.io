<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <link rel="canonical" href="https://lazzyrabbit.github.io//2016/08/04/Nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/">
    
    
    <title>Nginx内存池的初步分析 | 懒散集</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#2182C7">
    
    
    <meta name="keywords" content="nginx">
    <meta name="description" content="最近对Nginx进行了一些简单的剖析，要是剖析的不好希望大家见谅，本人水平有限哦 我们先看这么一副图                                                                                              nginx内存池数据结构逻辑图               在调用这个图片之前我想先首先声明一下这幅图的作者啊，">
<meta property="og:type" content="article">
<meta property="og:title" content="Nginx内存池的初步分析">
<meta property="og:url" content="https://lazzyrabbit.github.io/2016/08/04/Nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/">
<meta property="og:site_name" content="懒散集">
<meta property="og:description" content="最近对Nginx进行了一些简单的剖析，要是剖析的不好希望大家见谅，本人水平有限哦 我们先看这么一副图                                                                                              nginx内存池数据结构逻辑图               在调用这个图片之前我想先首先声明一下这幅图的作者啊，">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://lazzyrabbit.github.io/2016/08/04/Nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/nginx%E5%86%85%E5%AD%98%E6%B1%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%BB%E8%BE%91%E5%9B%BE.jpeg">
<meta property="article:published_time" content="2016-08-04T06:31:24.000Z">
<meta property="article:modified_time" content="2020-02-12T16:37:37.348Z">
<meta property="article:author" content="Zerber">
<meta property="article:tag" content="nginx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lazzyrabbit.github.io/2016/08/04/Nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/nginx%E5%86%85%E5%AD%98%E6%B1%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%BB%E8%BE%91%E5%9B%BE.jpeg">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/kaku.jpeg)">
      <div class="brand">
        <a href="/null" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/miao2.jpeg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Zerber</h5>
          <a href="mailto:暂时就不贴邮箱了" title="暂时就不贴邮箱了" class="mail">暂时就不贴邮箱了</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://twitter.com/Zerber_" target="_blank" >
                <i class="icon icon-lg icon-twitter"></i>
                Twitter
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Nginx内存池的初步分析</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Nginx内存池的初步分析</h1>
        <h5 class="subtitle">
            
                <time datetime="2016-08-04T06:31:24.000Z" itemprop="datePublished" class="page-time">
  2016-08-04
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    

<article id="post-Nginx内存池的初步分析"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Nginx内存池的初步分析</h1>
        <div class="post-meta">
            <time class="post-time" title="2016-08-04 14:31:24" datetime="2016-08-04T06:31:24.000Z"  itemprop="datePublished">2016-08-04</time>

            


            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>最近对Nginx进行了一些简单的剖析，要是剖析的不好希望大家见谅，本人水平有限哦</p>
<p>我们先看这么一副图</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2016/08/04/Nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/nginx内存池数据结构逻辑图.jpeg" alt="nginx内存池数据结构逻辑图" title>
                </div>
                <div class="image-caption">nginx内存池数据结构逻辑图</div>
            </figure>

<p>在调用这个图片之前我想先首先声明一下这幅图的作者啊，我可不想打着盗版的声音去用这幅图哦=   =！！！感谢这幅图的作者rainx！</p>
<p>好，下面我们来通过这个图来对整个内存池进行分析吧。<br>我们通过代码的对比来分析这幅图</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存池头部结构 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_pool_data_t</span>       d;<span class="comment">//对线程块的一个管理</span></span><br><span class="line">    <span class="keyword">size_t</span>                <span class="built_in">max</span>;<span class="comment">//最大值</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>           *current;<span class="comment">//当前指针指的是哪个内存块</span></span><br><span class="line">    <span class="keyword">ngx_chain_t</span>          *chain;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>     *large;<span class="comment">//大块内存</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>   *cleanup;<span class="comment">//清除某些特殊数据</span></span><br><span class="line">    <span class="keyword">ngx_log_t</span>            *<span class="built_in">log</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实我觉得我们先应该通过这个结构体和这幅图来了解一下nginx内存池，其实所谓的一个内存池是通过一个链表来进行管理的，而ngx_pool_t就是对一个节点进行管理的结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ngx_pool_data_t  d  &#x2F;&#x2F;这是对这一块ngx_pool_t的数据块的一个管理</span><br><span class="line">size_t  max  &#x2F;&#x2F;数据块的大小，也就是你所分配的这一块节点数据区域的大小</span><br><span class="line">ngx_pool_t  *current  &#x2F;&#x2F;当前可分配的ngx_pool_t</span><br><span class="line">ngx_pool_large_t     *large  &#x2F;&#x2F;大于max的用大块内存区域存储</span><br><span class="line">ngx_pool_cleanup_t   *cleanup  &#x2F;&#x2F;用于清除某些文件描述符或者其它的特殊结构</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    u_char               *last;<span class="comment">//当前内存池分配到此处，即下一次分配从此处开始</span></span><br><span class="line">    u_char               *<span class="built_in">end</span>;<span class="comment">//内存池结束位置</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>           *next;<span class="comment">//内存池里面有很多块内存，这些内存   </span></span><br><span class="line">                               <span class="comment">//块就是通过该指针连成链表的 </span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            failed;<span class="comment">//内存池分配失败次数</span></span><br><span class="line">&#125; <span class="keyword">ngx_pool_data_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u_char  *last  &#x2F;&#x2F;指向可以分配内存空间的地方，last实际上是作为已经分配的内存空间的末尾，而下一次数据分配就要从last开始到end，当然要是在分配的空间小于max的情况下，假如下一次所要求分配的空间大于max，那么则开辟大块内存</span><br><span class="line">u_char  *end  &#x2F;&#x2F;数据域最末尾的指针</span><br><span class="line">ngx_pool_t  *next  &#x2F;&#x2F;指向下一块ngx_pool_t，这是在内存分配不够，开辟了下一个ngx_pool_t的前提下</span><br><span class="line">ngx_uint_t  failed  &#x2F;&#x2F;假如我们的分配的内存空间过于的小，超过4次在此块ngx_pool_t分配不成功，那么我们的current就会指向下一个ngx_pool_t，这个就是记录失败次数的一个记录器</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;管理大块内存</span><br><span class="line">struct ngx_pool_large_s &#123;</span><br><span class="line">    ngx_pool_large_t     *next;&#x2F;&#x2F;下一块</span><br><span class="line">    void                 *alloc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们在这里强调一下，大块内存实际上是指在ngx_pool_t中大于max的需要分配的节点，当然每次分配都是在current节点中，ngx_pool_t中的large指针负责将这些节点串联起来<br>void  *alloc  //当然指的就是大块内存的分配区域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct ngx_pool_cleanup_s &#123;</span><br><span class="line">    ngx_pool_cleanup_pt   handler;&#x2F;&#x2F;处理特殊数据的回调函数</span><br><span class="line">    void                 *data;&#x2F;&#x2F;指向要清除的数据</span><br><span class="line">    ngx_pool_cleanup_t   *next;&#x2F;&#x2F;下一个cleanup callback  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然我想说这个结构体没啥好介绍的，当我们在内存池中加入打开了些文件描述符在释放前需要关闭这些文件描述符或者一些特殊结构需要释放的时候，我们会调用<strong>ngx_pool_cleanup_s</strong>中的<strong>handler</strong>函数，当然这也是一个节点，我们需要在处理这些特殊的结构或者文件描述符的时候用特定的回调函数handler，我们需要把这些handler串联起来，其实跟ngx_pool_large_s差不多，也是在当前的current下，而串联起来这些节点的是cleanup指针</p>
<hr>
<p>好啦，我能说nginx中内存池大致的结构我已经剖析完了，现在我们来分析一些对它的操作的函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_alloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_calloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ngx_pool_t</span> *<span class="title">ngx_create_pool</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_destroy_pool</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_reset_pool</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_palloc</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_pnalloc</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_pcalloc</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_pmemalign</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> alignment)</span></span>;</span><br></pre></td></tr></table></figure>

<p>咱们来一个个分析好吧:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">ngx_alloc(<span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>  *p;</span><br><span class="line"><span class="comment">//可以看出来底层调用了malloc</span></span><br><span class="line">    p = <span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno,</span><br><span class="line">                      <span class="string">"malloc(%uz) failed"</span>, <span class="built_in">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, <span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"malloc: %p:%uz"</span>, p, <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ngx_alloc</strong>我们可以把它看成一个底层调用函数，直接调用的malloc，当然这里是看起来跟内存池没有任何关系了，但是它应该算是内存池的底层调用函数</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">ngx_calloc(<span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>  *p;</span><br><span class="line"><span class="comment">//带清零作用的</span></span><br><span class="line">    p = ngx_alloc(<span class="built_in">size</span>, <span class="built_in">log</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        ngx_memzero(p, <span class="built_in">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里当然也是相当于一个底层调用函数，它只不过相当于从堆上分配了一块内存附带清零的作用，仅此而已</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ngx_pool_t *</span><br><span class="line">ngx_create_pool(size_t size, ngx_log_t *log)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_pool_t  *p;</span><br><span class="line"></span><br><span class="line">    p &#x3D; ngx_memalign(NGX_POOL_ALIGNMENT, size, log);</span><br><span class="line">    if (p &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;d.last &#x3D; (u_char *) p + sizeof(ngx_pool_t);</span><br><span class="line">    p-&gt;d.end &#x3D; (u_char *) p + size;</span><br><span class="line">    p-&gt;d.next &#x3D; NULL;</span><br><span class="line">    p-&gt;d.failed &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    size &#x3D; size - sizeof(ngx_pool_t);</span><br><span class="line">    p-&gt;max &#x3D; (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br><span class="line"></span><br><span class="line">    p-&gt;current &#x3D; p;</span><br><span class="line">    p-&gt;chain &#x3D; NULL;</span><br><span class="line">    p-&gt;large &#x3D; NULL;</span><br><span class="line">    p-&gt;cleanup &#x3D; NULL;</span><br><span class="line">    p-&gt;log &#x3D; log;</span><br><span class="line"></span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>诶嘿，这里就很奇怪啊，貌似没有用到上面的ngx_alloc()函数啊，不过没关系，我只能说它其实并没有调用ngx_alloc()这个接口，而它调用了另一个接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#x3D; ngx_memalign(NGX_POOL_ALIGNMENT, size, log);</span><br></pre></td></tr></table></figure>

<p>我们可以看到这个接口和上面的接口都不一样，那么可以进这个接口里面去看一下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">ngx_memalign(<span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>  *p;</span><br><span class="line">    <span class="keyword">int</span>    err;</span><br><span class="line"><span class="comment">//调用posix_memalign( )成功时会返回size字节的动态内存</span></span><br><span class="line"><span class="comment">//并且这块内存的地址是alignment的倍数</span></span><br><span class="line"><span class="comment">//参数alignment必须是2的幂，还是void指针的大小的倍数</span></span><br><span class="line">    err = posix_memalign(&amp;p, alignment, <span class="built_in">size</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它里面涵盖了一个叫做<strong>posix_memalign(&amp;p, alignment, size)</strong>的函数，那么这个函数的作用是干嘛的呢？我们知道POSIX标明了通过<strong>malloc(), calloc(), 和 realloc()</strong>返回的地址对于任何的C类型来说都是对齐的。在Linux中，这些函数返回的地址在32位系统是以8字节为边界对齐，在64位系统是以16字节为边界对齐的,而<strong>posix_memalign(&amp;p, alignment, size)</strong>的作用就是动态对齐。而在这里它则是按alignment大小来进行对齐的，其实也可以看一下这个玩意的大小吧:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define NGX_POOL_ALIGNMENT       16*</span><br></pre></td></tr></table></figure>

<p>嘿嘿，看到没有，它的大小是16哦！！！也就是说它是按16来进行对齐的，至于具体的posix_memalign(&amp;p, alignment, size)咋用，希望大家自己回去查一下吧。</p>
<p>当然我们也看过了ngx_memalign(…)函数，我们继续来看一下ngx_create_pool(…)函数，我们可以看到它对max进行了一个初始化:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;max &#x3D; (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br></pre></td></tr></table></figure>

<p>其实我一直很好奇这个地方啊，这个地方的max是经过传进来的值决定的，而假如，传进来的小于NGX_MAX_ALLOC_FROM_POOL，那么按size的大小来计算哦，这里我们再来顺带看一下NGX_MAX_ALLOC_FROM_POOL是什么:<br><strong>#define NGX_MAX_ALLOC_FROM_POOL  (ngx_pagesize - 1)</strong></p>
<p>对哦，这里是一个宏定义，定义的大小是4K-1个大小，那么我们姑且算在小于4K的情况下它按size大小来定义吧，其实我认为这里的唯一的好处就是它按分页机制去处理了一个最大内存，假如我不到4K我能节约性的从内存中拿合适的内存，当大于4K的时候我们就可以不考虑页面大小的问题了，直接就大块内存走起，当然，考不考虑4K不是我们说了算，而是刚开始申请的size大小说了算哦。</p>
<p>我一直觉得这个地方有个BUG，那就是假如传进来的size &lt; sizeof(ngx_pool_t)怎么办？不就成负数了？那么这个进程会不会因此挂掉？这个我就是不是很清楚了！！</p>
<hr>
<p>接下来看看<code>ngx_destroy_pool(ngx_pool_t *pool)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_destroy_pool</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>          *p, *n;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>    *l;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>  *c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先考虑cleanup函数，但是貌似我并没有找见有关的回调</span></span><br><span class="line">    <span class="keyword">for</span> (c = pool-&gt;cleanup; c; c = c-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler) &#123;</span><br><span class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                           <span class="string">"run cleanup: %p"</span>, c);</span><br><span class="line">            c-&gt;handler(c-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line"></span><br><span class="line">        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"free: %p"</span>, l-&gt;alloc);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">        <span class="keyword">for</span> (p = pool, n = pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        ngx_free(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以从这里看到它先调用了ngx_pool_t中的clean中的handler函数来清理一些它可能打开的文件描述符或者特殊结构，此时再free掉那些大块结构。当然，最后是把自己本身的节点给free掉了</p>
<hr>
<p><strong>void ngx_reset_pool(ngx_pool_t *pool)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ngx_reset_pool(<span class="keyword">ngx_pool_t</span> *pool)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>        *p;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>  *l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = pool; p; p = p-&gt;d.next) &#123;</span><br><span class="line">        p-&gt;d.last = (u_char *) p + <span class="keyword">sizeof</span>(<span class="keyword">ngx_pool_t</span>);</span><br><span class="line">        p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool-&gt;current = pool;</span><br><span class="line">    pool-&gt;chain = <span class="literal">NULL</span>;</span><br><span class="line">    pool-&gt;large = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数呢是内存池重置函数，它会将大块内存删掉并且把里面的东西给初始化哦！！</p>
<hr>
<p>下面说的就是<strong>void *ngx_palloc(ngx_pool_t *pool, size_t size)</strong>了吧</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">ngx_palloc</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>  *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &lt;= pool-&gt;<span class="built_in">max</span>) &#123;</span><br><span class="line"></span><br><span class="line">        p = pool-&gt;current;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            m = ngx_align_ptr(p-&gt;d.last, NGX_ALIGNMENT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">size_t</span>) (p-&gt;d.<span class="built_in">end</span> - m) &gt;= <span class="built_in">size</span>) &#123;</span><br><span class="line">                p-&gt;d.last = m + <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p = p-&gt;d.next;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ngx_palloc_block(pool, <span class="built_in">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ngx_palloc_large(pool, <span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到这里是从内存池中分配内存的一个函数，当我们前面创建好内存池之后，我们可以通过这里在一个ngx_pool_t中的数据段中分配节点，我们可以看到，它就只用了last和end两个标记位去标记剩余空间的大小，当我们空间大于max的时候直接用ngx_palloc_large(pool, size)调用大块内存，而假如小于max却在后面的ngx_pool_t中不够用的话则会调用ngx_palloc_block(pool, size)函数，其实内部就是重新申请了一块ngx_pool_t内存，调用的还是ngx_memalign(…)函数，有兴趣的朋友自己看看了。</p>
<p>当然后面还有一个<br><strong>void *ngx_pnalloc(ngx_pool_t *pool, size_t size);</strong><br>当然，这个函数和<strong>void *ngx_palloc(ngx_pool_t *pool, size_t size)</strong>最大的区别当然就是:<br><strong>void *ngx_palloc(ngx_pool_t *pool, size_t size)</strong>是对齐的<br><strong>void *ngx_palloc(ngx_pool_t *pool, size_t size)</strong>是不对齐的</p>
<hr>
<p>好了总结了那么多，觉得心好累啊！！！</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2020-02-12T16:37:37.348Z" itemprop="dateUpdated">2020-02-13 00:37:37</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="https://lazzyrabbit.github.io">
            <img src="/img/miao2.jpeg" alt="Zerber">
            Zerber
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lazzyrabbit.github.io/2016/08/04/Nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/&title=《Nginx内存池的初步分析》 — 懒散集&pic=https://lazzyrabbit.github.io/img/miao2.jpeg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lazzyrabbit.github.io/2016/08/04/Nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/&title=《Nginx内存池的初步分析》 — 懒散集&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lazzyrabbit.github.io/2016/08/04/Nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Nginx内存池的初步分析》 — 懒散集&url=https://lazzyrabbit.github.io/2016/08/04/Nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/&via=https://lazzyrabbit.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lazzyrabbit.github.io/2016/08/04/Nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2016/08/06/Muduo%E5%BA%93%E7%9A%84%E6%A1%86%E6%9E%B6%E5%89%96%E6%9E%90%E5%8F%8A%E6%80%BB%E7%BB%93(%E4%B8%80)/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Muduo库的框架剖析及总结(一)</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2016/04/21/%E5%AF%B9Run-Time%20Check%20Failure%20#3%E7%9A%84%E5%A4%84%E7%90%86%E4%BB%A5%E5%8F%8A%E7%90%86%E8%A7%A3/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Time Check Failure 处理以及理解</h4>
      </a>
    </div>
  
</nav>



    


<section class="comments" id="comments">
    <div id="disqus_thread"></div>
    <script>
    var disqus_shortname = 'true';
    lazyScripts.push('//' + disqus_shortname + '.disqus.com/embed.js')
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>
</section>



















</article>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
            <span>This blog is licensed under a <a rel="license noopener" href="https://creativecommons.org/licenses/by/4.0/" target="_blank">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Zerber &copy; 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://lazzyrabbit.github.io/2016/08/04/Nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/&title=《Nginx内存池的初步分析》 — 懒散集&pic=https://lazzyrabbit.github.io/img/miao2.jpeg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://lazzyrabbit.github.io/2016/08/04/Nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/&title=《Nginx内存池的初步分析》 — 懒散集&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://lazzyrabbit.github.io/2016/08/04/Nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Nginx内存池的初步分析》 — 懒散集&url=https://lazzyrabbit.github.io/2016/08/04/Nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/&via=https://lazzyrabbit.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://lazzyrabbit.github.io/2016/08/04/Nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://lazzyrabbit.github.io/2016/08/04/Nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>








<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '倒是希望你快点回家了=   =！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
